---
title: "The Anatomy of an Open Source Contribution"
publishedAt: "2024-5-20"
description: "Discussing my recent open source cntirbution to the RXDB library"
tags: ["rxdb", "react", "graphql", "opensource"]
articleType: "article"
og: "https://ucarecdn.com/2cf34f69-bcf8-4344-9bd2-4d38de6597f8/yesiwouldusereduxin2024.png"
status: "draft"
---

I recently landed a PR in [RxDB](https://github.com/pubkey/rxdb), a fairly large open-source repo. I would like to discuss the issue that my PR addressed, how I came across it, and the entire contribution process.

RxDB, if you're unfamiliar, is an offline, local-first, client-side database. It works by persisting data locally on the client side using a number of storage options and replicating the data to the server in the background. RxDB offers several options to facilitate this replication, one of which is GraphQL - the option I used in my app.

## The Problem

To understand the issue I encountered while working with RxDB, I'll need to give a brief overview of GraphQL.

GraphQL is a query language that allows us to specify in granular detail the exact data we need from our server. It all starts with a schema which describes our data and the operations we intend to perform on it:

```graphql
type User {
  id: ID!
  isActive: Boolean!
  username: String
}

type Todo {
  id: ID
  title: String!
  description: String
  completed: Boolean
  user: User!
}

input CreateTodoInput {
  title: String!
  description: String
}

type Query {
  allTodos: [Todo]
}

type Mutation {
  createTodo(input: CreateTodoInput!): Todo
}
```

Based on this schema, a client can use a GraphQL query to request data or trigger a mutation. On the server, these queries are validated and executed by resolvers. For example, a query to retrieve `allTodos` would look as like:

```graphql
query AllTodos {
  allTodos {
    id
    title
    description
    completed
    user {
      id
      isActive
      username
    }
  }
}
```

And the resulting JSON data would look like:

```json
{
  "data": {
    "allTodos": [
      {
        "id": "1",
        "title": "Buy groceries",
        "description": "Milk, eggs, bread",
        "completed": false,
        "user": {
          "id": "1",
          "isActive": true,
          "username": "johndoe"
        }
      }
    ]
  }
}
```

The key point to remember is that GraphQL queries can support deeply nested structures, as seen in the above example where user is nested within todos.

The server's resolver is responsible for 'resolving' a field and all its child properties based on the GraphQL query. Importantly, when a field is nested in a query, we need to specify the individual properties in which we're interested.

So a query like this to get all the sub-fields in the user field will throw a `GraphQLError` error:

```graphql
query AllTodos {
  allTodos {
    id
    title
    description
    completed
    user
  }
}
```

We will be coming back to this later.

Replication in RxDB operates through a push, pull, and streaming mechanism. You can read more about how that works [here](https://rxdb.info/replication.html). To replicate our changes with GraphQL, we need to create push and pull queries. We then pass these queries to the `replicateGraphQL` function provided by RxDB.

RxDB provides a number utility functions, such as `pullQueryBuilderFromRxSchema`, which automatically generates the necessary GraphQL queries from the RxDB database schema. This schema adheres to the [JSON Schema](http://json-schema.org/) standard:

```javascript
const RXSchema = {
  version: 0,
  primaryKey: "passportId",
  type: "object",
  properties: {
    passportId: {
      type: "string",
      maxLength: 100,
    },
    firstName: {
      type: "string",
    },
    lastName: {
      type: "string",
    },
    age: {
      type: "integer",
      minimum: 0,
      maximum: 150,
    },
    updatedAt: {
      type: "string",
    },
    address: {
      type: "object",
      properties: {
        street: {
          type: "string",
        },
        city: {
          type: "string",
        },
        zip: {
          type: "string",
        },
      },
    },
  },
};

const pullQuery = pullQueryBuilderFromRxSchema(RXSchema);
```

After logging the return of the `pullQueryBuilderFromRxSchema` function, this is what I got in the query field:

```graphql
query PullHuman($checkpoint: HumanInputCheckpoint, $limit: Int!) {
  pullHuman(checkpoint: $checkpoint, limit: $limit) {
    documents {
      passportId
      firstName
      lastName
      age
      updatedAt
      address
      _deleted
    }
    checkpoint {
      passportId
      updatedAt
    }
  }
}
```

If you notice, the generated schema does not match our `RXschema` - specifically, the `pullHuman` query does not include the subfields for the address, hence the error.

GraphQL requires that you construct your queries in a way that only returns concrete data. Each field must ultimately resolve to one or more fields.

Searching the RxDB repo, we can identify the issue in the [source](https://github.com/pubkey/rxdb/blob/4516a6873b5e01dcae35cf4ace97837c927b64a6/src/plugins/replication-graphql/query-builder-from-rx-schema.ts) of the `pullQueryBuilderFromRxSchema`:

```graphql
export function pullQueryBuilderFromRxSchema(
    collectionName: string,
    input: GraphQLSchemaFromRxSchemaInputSingleCollection,
): RxGraphQLReplicationPullQueryBuilder<any> {
		...
    const outputFields = Object.keys(schema.properties).filter(k => !(input.ignoreOutputKeys as string[]).includes(k));
    // outputFields.push(input.deletedField);

    const checkpointInputName = ucCollectionName + 'Input' + prefixes.checkpoint;

    const builder: RxGraphQLReplicationPullQueryBuilder<any> = (checkpoint: any, limit: number) => {
        const query = 'query ' + operationName + '($checkpoint: ' + checkpointInputName + ', $limit: Int!) {\n' +
            SPACING + SPACING + queryName + '(checkpoint: $checkpoint, limit: $limit) {\n' +
            SPACING + SPACING + SPACING + 'documents {\n' +
            SPACING + SPACING + SPACING + SPACING + outputFields.join('\n' + SPACING + SPACING + SPACING + SPACING) + '\n' +
            SPACING + SPACING + SPACING + '}\n' +
            SPACING + SPACING + SPACING + 'checkpoint {\n' +
            SPACING + SPACING + SPACING + SPACING + input.checkpointFields.join('\n' + SPACING + SPACING + SPACING + SPACING) + '\n' +
            SPACING + SPACING + SPACING + '}\n' +
            SPACING + SPACING + '}\n' +
            '}';
        return {
            query,
            operationName,
            variables: {
                checkpoint,
                limit
            }
        };
    };

    return builder;
}

```

The issue lies with `outputFields`, which only considers the top-level keys of schema.properties. This explains why I was encountering a problem.

## Making the contribution

The issue seemed relatively straightforward to fix. It didn't involve the core database code and was isolated enough for me to understand without knowing the larger codebase.

This is not typically the case for open source projects, where you usually need to spend some time understanding the codebase to make a contribution.

Following the [instructions](https://rxdb.info/contribution.html), I opened an [issue](https://github.com/pubkey/rxdb/issues/5969) and submitted a failing test PR to illustrate the problem [here](https://github.com/pubkey/rxdb/pull/5968). After receiving feedback from the contributor, I opened a [PR](https://github.com/pubkey/rxdb/pull/5976) which was merged a few days later.

The solution involved using recursion to recursively process the output fields based on the schema. Here's the core function I added:

```tsx
type GenerateGQLOutputFieldsOptions = {
  schema: RxJsonSchema<any> | TopLevelProperty;
  spaceCount?: number;
  depth?: number;
  ignoreOutputKeys?: string[];
};

function generateGQLOutputFields(options: GenerateGQLOutputFieldsOptions) {
  const { schema, spaceCount = 4, depth = 0, ignoreOutputKeys = [] } = options;

  const outputFields: string[] = [];
  const properties = schema.properties;
  const NESTED_SPACING = SPACING.repeat(depth);
  const LINE_SPACING = SPACING.repeat(spaceCount);

  for (const key in properties) {
    //only skipping top level keys that are in ignoreOutputKeys list
    if (ignoreOutputKeys.includes(key)) {
      continue;
    }

    const value = properties[key];
    if (value.type === "object") {
      outputFields.push(
        LINE_SPACING + NESTED_SPACING + key + " {",
        generateGQLOutputFields({
          schema: value,
          spaceCount,
          depth: depth + 1,
        }),
        LINE_SPACING + NESTED_SPACING + "}"
      );
    } else {
      outputFields.push(LINE_SPACING + NESTED_SPACING + key);
    }
  }

  return outputFields.join("\n");
}
```

I rarely use recursion in my day job, so it was nice to see a clear use case here.

## Learnings

This PR marks my most significant contribution to a relatively large open-source project, and I'm pleased with the outcome.

Mitchell's blog post on **[Contributing to Complex Projects](https://mitchellh.com/writing/contributing-to-complex-projects#step-3-learn-the-hot-path-internals)** served as a helpful guide. I believe the key to my effective contribution was that I was interfacing as an RxDb user, addressing an issue that I encountered. This placed me in an optimal position to resolve the problem effectively.

I hope you enjoyed this walkthrough of the contribution. I'm interested in hearing your thoughts and feedback.

Until next time.
