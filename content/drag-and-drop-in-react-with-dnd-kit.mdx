---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is an awesome library I recently discovered while working on the new dashboard at [Super](https://super.so/). It simplifies the complex task of creating performant Drag-and-Drop UI interactions, with some interesting patterns and concepts. I spent some time creating a lot of cool interactions with the library and wanted to share some of the things I learned.

If you're already familiar with DnD Kit, or just want to see code examples, jump straight to them [here](#examples). Otherwise, keep reading to learn more about the library and how to get started.

Let's begin!

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
  If you're new to React, I recommend reading
  [this](https://reactjs.org/docs/getting-started.html) and
  [this](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup/). If
  you're new to Typescript, I recommend reading
  [this](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html).
</Callout>

## Core Concepts

From a high-level, most drag-and-drop UI interactions involve three main elements: a draggable component, a droppable area, and a system that manages the interaction between them. The draggable element can be dragged, and the drop area is where it can be dropped. To gain a better understanding of how these components work, you can try out the demo below:

<FreeDnd />

In the demo above, the droppable area covers the entire page, allowing us to drop draggable elements anywhere. This is similar to canvas-based applications like Figma and Excalidraw. But we can also have fixed, designated drop areas, like this:

<DroppableDnd />

DndKit is built around this approach, offering three core primitives:

- The `useDraggable` hook, which turns DOM elements into draggable sources that can be picked up, dragged, and dropped over droppable areas.
- The `useDroppable` hook, which sets up DOM elements as droppable areas that draggable elements can be dropped over; and
- The `<DndContext />` component, which manages the interaction between draggable and droppable components via React Context API.

<Callout intent="info" heading="The React Context API">
  The React Context API is a way to share data between components without having
  to pass props down manually at every level. You can read more about it
  [here](https://reactjs.org/docs/context.html).
</Callout>

These primitives are exported from the `@dnd-kit/core` package; you can install it by running:

```shell
yarn add @dnd-kit/core
```

Let's go over each of them in detail.

### Draggable

Creating a draggable component is easy with the useDraggable hook. It takes an input object as an argument, which must include a unique id. It returns an object with several properties. We are currently interested in four of these properties:

1. `setNodeRef` - A callback `ref` we attach to the HTML element we want to make draggable. This is an essential part of how we provide dndkit with the element that needs to be dragged.
2. `listeners` - An object we spread on the HTML element that we want to use as triggers to start dragging. We can use this to create drag handles for our draggable elements.
3. `attributes` - An object with sensible defaults for accessibility that can be spread on the activator HTML element, along with the `listeners` object.
4. `transform` - An object with the x- and y-coordinates of a draggable element in 2D, which is updated as it is being dragged. We'll use this to update the CSS `translate` property, allowing us to move the draggable component on the screen.

<Callout intent="info" heading="Callback Refs">
  Callback refs are a way to access DOM nodes in React. You can read more about
  them [here](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs).
</Callout>

Here is an example of how all these elements work together to create a draggable component:

```tsx
import { useDraggable } from "@dnd-kit/core";
//CSS helper for generating CSS transform strings
import { CSS } from "@dnd-kit/utilities";

function Draggable() {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "unique-id",
  });

  const transformStyle = {
    transform: CSS.Transform.toString(transform),
  };

  return (
    <button
      ref={setNodeRef}
      style={{ ...transformStyle }}
      {...listeners}
      {...attributes}
    >
      {/* Render whatever you like within */}
    </button>
  );
}
```

### Droppables

The `useDroppable` hook sets up HTML elements as droppable areas. It takes an input object with a required unique id as an argument and returns an object with several properties. We are currently interested in two of these properties:

1. `setNodeRef` - a callback `ref` we attach to the HTML element we want to make droppable. This is how we tell DndKit that an element is a drop area.
2. `isOver` - a Boolean that indicates whether a draggable component is over the droppable area. We can use this to conditionally style droppable areas.

```tsx
import { useDroppable, isOver } from "@dnd-kit/core";

function Droppable() {
  const { setNodeRef } = useDroppable({
    id: "unique-id",
  });

  return <div ref={setNodeRef}>{/* Render whatever you like within */}</div>;
}
```

### DndContext

The `<DndContext>` component manages the interactions between our draggable and droppable components. To make sure they work properly, we must wrap them within the `<DndContext>` component:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";

function App() {
  return (
    <DndContext>
      <Draggable />
      <Droppable />
    </DndContext>
  );
}
```

The `<DndContext>` provides many props to configure the behaviour of our draggable and droppable components. For a full API reference, please refer to the documentation. The most important props at this point are the `events` and `sensors` props.

#### Events

The `<DndContext>` emits various events during different stages of drag-and-drop interaction. We can use this information to configure the behaviour of draggable and droppable components. The main events are:

- `onDragStart`, which fires when a draggable is dragged and contains an object with information about the active draggable element.
- `onDragOver`, which fires when a draggable item is dragged over a droppable area. It contains an object with information about the droppable area and the draggable element.
- `onDragEnd`, which fires after a draggable item is dropped. It includes information on the active draggable `id` and whether the draggable item was dropped over a droppable area.
- `onDragCancel`, which fires if a drag operation is cancelled, e.g. if the user presses `escape` while dragging a draggable item.

We can handle these events with functions, using the event data to update the state of our draggable and droppable components in the UI. This gives us great flexibility.

To visualise when the `<DndContext>` emits different events, play around with the demo below:

<DroppableDnd />

#### Sensors

The `<DndContext>` uses sensors to detect drag-and-drop interactions. Sensors are responsible for detecting when a draggable item is being dragged, and when it is dropped. The `<DndContext>` comes with a few sensors out of the box, but you can also create your own. The most common sensors are:

- `MouseSensor` - Detects mouse events to determine when a draggable item is being dragged.
- `TouchSensor` - Detects touch events to determine when a draggable item is being dragged.
- `KeyboardSensor` - Detects keyboard events to determine when a draggable item is being dragged.

To use a sensor, we need to pass it to the `<DndContext>` as an array of sensors:

```tsx
import { DndContext, MouseSensor, TouchSensor } from "@dnd-kit/core";

function App() {
  return (
    <DndContext
      sensors={[MouseSensor, TouchSensor]}
      collisionDetection={closestCenter}
    >
      {/* Render draggable and droppable components */}
    </DndContext>
  );
}
```

## Examples

Now that we've discussed the core concepts of the Dndkit, let's go through examples of how to use them to create beautiful drag-and-drop interactions. We'll cover four common use cases found on the web:

- **Free Drag-and-Drop**: Drag-and-drop elements across the entire screen, similar to canvas-based applications such as Figma and Excalidraw.
- **Droppable Containers**: Drag and drop items into one or more designated areas.
- **Single Container Sortables**: Rearrange the order of list items within a single container by dragging them.
- **Multi-Container Sortables**: Drag items between multiple Sortable containers

### Free Drag-and-Drop

This interaction is similar to the demo at the start of this post. Here is a simplified example for reference:

<FreeDnd hideFooter />

If you just want to see completed code for this without an explanation, click [here](#free-dnd-sandpack). Otherwise, let's go through the code step-by-step.

In this interaction, we have multiple draggable components. To build this, we need to create a Draggable Component with the useDraggable hook. This component takes a unique id, and a styles object as props:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

//First create a draggable component
type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform, isDragging } =
    useDraggable({
      id,
    });

  const transformStyles = transform
    ? {
        transform: CSS.Translate.toString(transform),
      }
    : {};

  return (
    <div
      ref={setNodeRef}
      style={{ ...transformStyles, ...styles }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next we need to set up our DndContext and the state of our Draggable components. We'll be storing the data about our draggable components as an array of objects in state. Each object should include a unique ID and the initial x and y position coordinates of the element:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  //initial draggble state
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

To allow our components to be moved around the page, we need to update their positions when a drag event ends. We'll use the `onDragEnd` event emitted by the `<DndContext />` to do this. This event contains the x- and y-positions of the active draggable element when it is dropped. In our handler function, we can use this information to update the position of our element in state:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

//Create a handler function to respond to an ondragend event & update the position of the draggable element
export function App() {
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  function handleDragEnd(ev: DragEndEvent) {
    const activeId = ev.active.id;

    //if there is no active draggable return
    if (!activeId) {
      return;
    }

    //find active draggable in state and update its position
    const draggable = draggables.find((x) => x.id === ev.active.id);
    draggable.position.x += ev.delta.x;
    draggable.position.y += ev.delta.y;
    const _draggables = draggables.map((d) =>
      d.id === draggable.id ? draggable : d
    );

    setDraggables(_draggables);
  }

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

You see How these comes together by playing with the interactive code example below:

<FreeDnDSandPack />

### Droppable Containers

This interaction is similar to the demo at the start of this post. Here is a simplified example for reference:

<DroppableDnd hideStatus />

If you just want to see completed code for this without an explanation, click [here](#classic-dnd-sandpack). Otherwise, let's go through the code step-by-step.

### Single Container Sortables

This interaction is similar to the demo at the start of this post. Here is a simplified example for reference:

<SingleContainerSortable />

If you just want to see completed code for this without an explanation, click [here](#classic-dnd-sandpack). Otherwise, let's go through the code step-by-step.

### Multi-Container Sortables

This interaction is similar to the demo at the start of this post. Here is a simplified example for reference:

<MultiContainerSortable />

If you just want to see completed code for this without an explanation, click [here](#classic-dnd-sandpack). Otherwise, let's go through the code step-by-step.

## Closing Thoughts
