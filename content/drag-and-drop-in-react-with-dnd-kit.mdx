---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is a relatively new, hook-based library that makes it easy to create performant and accessible drag-and-drop UI interactions in React. I have been using the library a lot at Super, particularly in our new dashboard, and I wanted to share some examples of what can be achieved with DnD Kit.

If you're already familiar with DnD Kit, or just want to take a look at the code examples, you can jump straight to them [here](#examples). Otherwise, read on to learn more about the library and how to get started.

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

Drag-and-drop interactions on the web typically involve three elements:

- a **draggable component** that can be dragged,
- a **droppable area** where draggable components can be dropped over, and
- a **system that manages** the interaction between the draggable components and the droppable areas.

To see how these elements typically come together, you can play with the demo below:

<FreeDnd />

In the demo, we can drag our draggable components and drop them anywhere on the page. However, we can also restrict the dropping of our draggable components to particular droppable areas on the page:
In the demo, we can drag our draggable components and drop them anywhere on the page. However, we can also restrict the dropping of our draggable components to particular droppable areas:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives exported from the `@dnd-kit/core` package:

1. The [`useDraggable`](https://docs.dndkit.com/api-documentation/draggable) hook - A React hook which makes HTML elements draggable.
2. The [`useDroppable`](https://docs.dndkit.com/api-documentation/droppable) hook - A React hook which makes HTML elements droppable areas.
3. The [`DndContext`](https://docs.dndkit.com/api-documentation/context-provider) - A context provider which manages the interaction between draggable and droppable components using the React Context API.

Often, drag-and-drop interactions require more than just dragging and dropping components. For example, take a look at the demo below:

<SortableDnd />

In the demo, we have a list and when we drag a single list item, it automatically sorts with the other items. This interaction is called "Sortables", where components, referred to as "Sortable Components", are both draggable and droppable.

We can use Sortable Components in many ways. For example, we can have Sortable containers that contain sortable lists, allowing users to sort containers, list items, and drag list items between containers:

<SortableMultiDnd />

To handle this use case, DnDKit exposes a set of presets from the `@dnd-kit/sortable` package:

1. The [`useSortable`](https://docs.dndkit.com/presets/sortable/sortable-context) hook - A react hook which makes HTML elements sortable. The hook is a combination of the `useDraggable` and `useDroppable` hooks.
2. The [`SortableContext`](https://docs.dndkit.com/presets/sortable/usesortable) - An additional context provider which manages the interactions between sortable components.

Let's now explore how to use the primitives and presets to create various drag-and-drop interactions.

## Examples

We'll be looking at four common types of drag and drop interactions:

1. **Free Drag-and-Drop** - Drag draggable components across the entire page, similar to apps such as Figma and Excalidraw.
2. **Droppable Containers** - Drag multiple draggable components into one or more designated droppable containers.
3. **Single Container Sortable List** - A sortable list within a single container.
4. **Multi-Container Sortable List** - Sortable lists within multiple sortable containers.

### Free Drag-and-Drop

A user interface allows users to pick up and drag an element across the entire page.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
First, we create a `Draggable` component with the `useDraggable` hook.  This component takes a unique `id`, and a `styles` object as `props`:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id,
  });

  return (
    <div
      //Sets up the draggable element
      ref={setNodeRef}
      style={{
        ...styles,
        //Updates the position of the draggable element as it is dragged
        transform: CSS.Translate.toString(transform),
      }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next, we set up our `DndContext` and the state of our `Draggable` components. The data about our `Draggable` components are stored in state as an array of objects.

Each object includes a unique `id` , a `name` and the initial `x` and `y` positions of our `Draggable` components:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  //The state of our draggable components
  const [draggables, setDraggables] = React.useState([
    {
      id: "DG",
      name: "D",
      position: {
        x: 24,
        y: 24,
      },
    },
    {
      id: "KA",
      name: "K",
      position: {
        x: 164,
        y: 164,
      },
    },
  ]);

  //sensors are used to detect drag events see more at https://docs.dndkit.com/api-documentation/sensors
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      //we implement this handler below
      onDragEnd={handleDragEnd}
    >
      {draggables.map((d) => (
        <Draggable
          {...d}
          key={d.id}
          //We pass the current position of the draggables here as CSS styles
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

We use the `onDragEnd` event emitted by the `DndContext` to update the positions of our components when a drag event ends. This event contains the `x` and `y` positions of the active `Draggable` component when it is dropped.

In our handler function, we access this information and use it to update the position of our `Draggable` components in state:

```tsx
//Handler function to respond to an onDragEnd event
function handleDragEnd(ev: DragEndEvent) {
  const { active, delta } = ev;

  //if there is no active draggable, return
  if (!active) return;

  //find the active draggable in state
  const draggable = draggables.find((d) => d.id === active.id);

  //update the position of the active draggable
  draggable.position.x += delta.x;
  draggable.position.y += delta.y;

  setDraggables((draggables) =>
    //update the state of the active draggable with the new position
    draggables.map((d) => (d.id === draggable.id ? draggable : d))
  );
}
```

</Callout>

### Droppable Containers

A user interface allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
We need a `Draggable` component. This component is identical to the one we created in the free drag and drop example above, so I will omit the implementation here.

As we have designated droppable areas, we create a `Droppable` component with the `useDropabale` hook. This component takes a unique `id` as props, similar to the `Draggable` component:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: id,
  });

  return (
    <div
      ref={setNodeRef}
      style={{
        //Conditional styles to indicate when a draggable is over a droppable area
        color: isOver ? "gray" : undefined,
      }}
    >
      {children}
    </div>
  );
}
```

Next, we set up our `DndContext` and the state of our `Draggable` and `Droppable` components:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragOverEvent,
} from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";
import React from "react";

export default function App() {
  //set up state for draggable and droppable components
  //The state is an object where the keys are the ids of the
  //droppable components and the values are an array of draggable
  //components that are currently in the droppable area
  const [items, setItems] = React.useState({
    A: [
      {
        id: "KV9DAsrRh2",
        name: "AQ",
      },
      {
        id: "KDVGlBlDXX",
        name: "CO",
      },
    ],
    B: [
      {
        id: "wXl_8K1JaC",
        name: "BL",
      },
      {
        id: "3MF7jrHKqd",
        name: "JA",
      },
    ],
  });

  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      onDragOver={handleDragOver}
      //optimised collision detection see https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms for more info
      collisionDetection={closestCorners}
    >
      {/** map over the object in state and render a droppable component for each item */}
      <div className="app">
        {Object.entries(items).map(([key, value]) => (
          <Droppable key={key} id={key}>
            {value.map((item) => (
              //render a draggable component for each item in the droppable container
              <Draggable key={item.id} id={item.id} name={item.name} />
            ))}
          </Droppable>
        ))}
      </div>
    </DndContext>
  );
}
```

We use `findContainer`, a helper function, to get the `ids` of `Droppable` containers that have an active `Draggable` component, or one over them. This helps us in `handleDragEnd` to identify the `Droppable` containers we want to update in state at the end of a drag event:

```tsx
function findContainer(id: string) {
  //if the id is a key in the items object, that means it is a droppable container
  if (id in items) {
    return id;
  }

  //if the id is not a key in the items object, that means it is a draggable item and we need to find the container it is in
  //we can do this by looping over the items object and checking if the id is in the array of items
  return Object.keys(items).find((key) => {
    return items[key].some((item) => item.id === id);
  });
}

function handleDragOver(ev: DragOverEvent) {
  const { active, over } = ev;

  //if there is no active draggable or no droppable container, return
  if (!over || !active) {
    return;
  }
  const activeId = active.id;
  const overId = over?.id;

  //find the active and over containers
  const activeContainer = findContainer(activeId);
  const overContainer = findContainer(overId);

  //if there is no active container or no over container, or if the active container is the same as the over container, no need to update state so return
  if (!activeContainer || !overContainer || activeContainer === overContainer) {
    return;
  }

  setItems((items) => {
    //find the active item and the items in the active and over containers
    const activeItems = items[activeContainer];
    const overItems = items[overContainer];
    const activeItem = activeItems.find((item) => item.id === activeId);

    //update the items in state
    const newItems = {
      ...items,
      //remove the active item from the active container
      [activeContainer]: activeItems.filter((item) => item.id !== activeId),
      //add the active item to the over container
      [overContainer]: [...overItems, activeItem],
    } as Items;

    return newItems;
  });
}
```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<SortableDndSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
First, we create a `SortableItem` component with the `useSortable` hook. This component takes a unique `id` and a `name` as props:

```tsx
import { CSS } from "@dnd-kit/utilities";
import { useSortable } from "@dnd-kit/sortable";
import { DragHandleDots2Icon } from "@radix-ui/react-icons";

type SortableItemProps = {
  id: string;
  name?: string;
};

export function SortableItem(props: SortableItemProps) {
  const { name, id } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: id,
  });

  //set up the transform and transition styles for the draggable component
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }}>
      {/** add the drag handle */}
      <DragHandleDots2Icon
        className="drag-handle"
        {...listeners}
        {...attributes}
      />
      <span>{name}</span>
    </div>
  );
}
```

Next, we set up our `DndContext` and the state of our `SortableItem` component, which is a simple array:

```tsx
import React from "react";
import type { DragEndEvent } from "@dnd-kit/core";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { SortableItem } from "./SortableItem";

export default function App() {
  const [sortables, setSortables] = React.useState([
    {
      id: "dnuannvBxx",
      name: "GOLD",
    },
    {
      id: "mrY2amrFiv",
      name: "BRONZE",
    },
    {
      id: "Y7UE3g7kD2",
      name: "APRICOT",
    },
    {
      id: "kZ9B3D_JyO",
      name: "BEIGE",
    },
  ]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      //collision detection algorithm best suited for single container sortables,
      //see more at https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms
      collisionDetection={closestCenter}
      sensors={sensors}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={sortables}
        //sorting strategy suited for vertical lists
        //see https://docs.dndkit.com/presets/sortable#sorting-strategies for more
        strategy={verticalListSortingStrategy}
      >
        <div className="app">
          {sortables.map((s) => (
            <SortableItem key={s.id} {...s} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );
}
```

Finally, we update the positions of our sortable items at the end of the drag event using the `onDragEnd` event emitted by the `DndContext`:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  //if there is no active draggable or no droppable container, return
  if (!over || !active) return;
  const activeId = active.id;
  const overId = over?.id;

  if (activeId && overId && active.id !== over.id) {
    setSortables((items) => {
      //find the index of the active and over items and use arrayMove to update the items in state
      const oldIndex = sortables.findIndex((f) => f.id === activeId);
      const newIndex = sortables.findIndex((f) => f.id === overId);
      return arrayMove(items, oldIndex, newIndex);
    });
  }
}
```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<SortableMultiDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
We need a `SortableItem` component. This component is identical to the one we created in the single container sortable list example above, so I will omit the implementation here.

Our containers are sortable, so we create a `SortableContainer` component. This is quite similar to the `SortableItem`, but we need to add an empty `Droppable` container when it has no items:

```tsx
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Item } from "./items";
import { CSS } from "@dnd-kit/utilities";
import { useDroppable } from "@dnd-kit/core";
import { SortableItem } from "./SortableItem";

type SortableContainerProps = {
  id: string;
  name?: string;
  items: Item[];
};

type DroppableProps = {
  id: string;
  children?: React.ReactNode;
  className?: string;
};

export function Droppable(props: DroppableProps) {
  const { id, children, className } = props;

  const { setNodeRef } = useDroppable({
    id,
  });

  return (
    <div ref={setNodeRef} className={className}>
      {children}
    </div>
  );
}

export function SortableContainer(props: SortableContainerProps) {
  const { name, id, items } = props;
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({
      id: id,
      data: { name, type: "container" },
    });
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }} className="sortable-container">
      <div>
        <div
          {...listeners}
          {...attributes}
          className="sortable-container_header"
        >
          {name}
        </div>
        {/** if there are no items in the container, render an empty droppable container with the same id as the SortableContainer */}
        {items.length === 0 ? (
          <Droppable id={id} key={id} className="droppable">
            List is empty
          </Droppable>
        ) : (
          <SortableContext items={items} strategy={verticalListSortingStrategy}>
            {items.map((s) => (
              <SortableItem {...s} key={s.id} />
            ))}
          </SortableContext>
        )}
      </div>
    </div>
  );
}
```

Next, we set up our `DndContext` and the state of our items and containers:

```tsx
import {
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragEndEvent,
  DragOverEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  horizontalListSortingStrategy,
  SortableContext,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable";
import React from "react";
import { SortableContainer } from "./SortableContainer";

export default function App() {
  //state of the items
  const [sortables, setSortables] = React.useState([
    {
      id: "A",
      name: "Container A",
      //helper function to create an array of draggbale items
      items: createData(3, (index) => `ITEM A${index + 1}`),
    },
    {
      id: "B",
      name: "Container B",
      //helper function to create an array of draggbale items
      items: createData(2, (index) => `ITEM B${index + 1}`),
    },
  ]);

  //remember to set up your sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      collisionDetection={closestCorners}
      sensors={sensors}
      //we will implment the handlers below
      onDragEnd={handleDragEnd}
      onDragOver={handleDragOver}
    >
      <SortableContext
        items={sortables}
        strategy={horizontalListSortingStrategy}
      >
        {sortables.map((s) => (
          <SortableContainer
            key={s.id}
            id={s.id}
            name={s.name}
            items={s.items}
          />
        ))}
      </SortableContext>
    </DndContext>
  );
}
```

We respond to two events in this example:

- `onDragOver` when a `SortableItem` is dragged over a `SortableContainer`;
- `onDragEnd` when a `SortableContainer` is sorted with other `SortableContainer's` or when a `SortableItem` is sorted within a `SortableContainer`.

In the `onDragOver` handler, we use two helper functions: `findContainer`, which finds the relevant container based on the id passed in, and `isSortingContainers`, which returns true if the active and over items are both `SortableContainers`:

```tsx
function findContainer(id?: string) {
  if (id) {
    //find the container id based on the id of container item
    const container = sortables?.find((i) =>
      i.items?.find((l) => l?.id === id)
    );

    return container?.id;
  }
}

function isSortingContainers(activeId: string, overId: string) {
  return (
    sortables.map((s) => s.id).includes(overId) &&
    sortables.map((s) => s.id).includes(activeId)
  );
}

function handleDragOver(event: DragOverEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!over || !activeId || !overId) return;
  const activeContainerId = findContainer(activeId);
  const overContainerId = findContainer(overId);

  //If there is no active container or over container, return early
  if (!overContainerId || !activeContainerId) return;

  //In this example we can not drag a container over another container, is if we are sorting the containers
  //we will return early and not update the state
  if (isSortingContainers(activeId, overId)) return;

  //Only update state when the active container is not the same as the over container
  if (activeContainerId !== overContainerId) {
    //Find active and over items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const overContainer = sortables.find((i) => i.id === overContainerId);
    const activeItems = activeContainer?.items || [];
    const activeIndex = activeItems.findIndex((i) => i.id === active.id);
    const overItems = overContainer?.items || [];
    const overIndex = sortables.findIndex((i) => i.id === over.id);

    //Need to find the newindex to insert the active item into the over container
    let newIndex: number;
    //check if container is empty, if it is we will add the active item to the end of the container
    if (sortables.map((s) => s.id).includes(over.id as string)) {
      newIndex = overItems.length + 1;
    } else {
      //if the container is not empty we will check if the active item is below the over item and update the index accordingly
      const isBelowOverItem =
        over &&
        active.rect.current.translated &&
        active.rect.current.translated.top > over.rect.top + over.rect.height;
      const modifier = isBelowOverItem ? 1 : 0;
      newIndex = overIndex >= 0 ? overIndex + modifier : overItems.length + 1;
    }

    const newItems = sortables.map((item) =>
      // Remove the active item from the old container
      item.id === activeContainerId
        ? {
            ...item,
            items: activeItems.filter((item) => item.id !== active.id),
          }
        : // Add the active item to the new container at the new index
        item.id === overContainerId
        ? {
            ...item,
            items: [
              ...item.items.slice(0, newIndex),
              activeItems[activeIndex],
              ...overItems.slice(newIndex, item.items.length),
            ],
          }
        : item
    );

    //update the state
    setSortables(newItems);
  }
}
```

In the `onDragEnd` handler, we handle two cases: sorting a `SortableContainer` and sorting a `SortableItem` within a `SortableContainer`:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!activeId || !overId) return;
  const activeContainerId = findContainer(activeId);

  //If we are sorting the containers, we will update the state to reflect the new order of the containers
  if (isSortingContainers(activeId, overId)) {
    if (activeId !== overId) {
      setSortables((items) => {
        const oldIndex = sortables.findIndex((f) => f.id === activeId);
        const newIndex = sortables.findIndex((f) => f.id === overId);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  } else {
    //Update the state to reflect the new order of the items inside the containers, iuf we are sorting the items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const activeItems = activeContainer?.items || [];
    const oldIndex = activeItems.findIndex((i) => i.id === activeId);
    const newIndex = activeItems.findIndex((i) => i.id === overId);
    const newItems = sortables.map((s) =>
      //Find the active container and update the items inside the container
      s.id === activeContainerId
        ? {
            ...s,
            items: arrayMove(s.items, oldIndex, newIndex),
          }
        : s
    );

    //Only update the state if the active item has moved
    if (oldIndex !== newIndex) {
      setSortables(newItems);
    }
  }
}
```

</Callout>

## Closing Thoughts

I hope I managed to demonstrate the power of DndKit. Its strength lies in its flexibility. You can use it to create anything from a simple to-do list to a complex drag-and-drop interface.

I hope you enjoyed this post. If you have any questions, you can reach me on Twitter [@kxlaa\_](https://twitter.com/kxlaa_) and I'll be happy to answer them.

Thank you for reading and happy coding!
