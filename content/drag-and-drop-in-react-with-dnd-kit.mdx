---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is a relatively new, hook-based library that makes it easy to create performant and accessible drag-and-drop UI interactions in React. I have been using the library a lot at Super, particularly in our new dashboard, and I wanted to share some examples of what can be achieved with DnD Kit.

In this post, I will provide a brief overview of the fundamentals of DnD Kit and then move on to code examples with explanations. If you need more information about DnD Kit, you can always consult the documentation.

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

Drag-and-drop interactions on the web typically involve three elements:

- a **draggable component** that can be dragged,
- a **droppable area** where draggable components can be dropped over, and
- a **system that manages** the interaction between the draggable components and the droppable areas.

To see how these elements typically come together, you can play with the demo below:

<FreeDnd />

In the demo, we can drag our draggable components and drop them anywhere on the page. However, we can also restrict the dropping of our draggable components to particular droppable areas:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives exported from the `@dnd-kit/core` package:

1. The `useDraggable` hook - A React hook which makes HTML elements draggable.
2. The `useDroppable` hook - A React hook which makes HTML elements droppable areas.
3. The `DndContext` - A context provider which manages the interaction between draggable and droppable components using the React Context API.

Often, drag-and-drop interactions require more than just dragging and dropping components. For example, take a look at the demo below:

<SortableDnd />

In the demo, we have a list and when we drag a single list item, it automatically sorts with the other items. This interaction is called "Sortables", where components, referred to as "Sortable Components", are both draggable and droppable.

We can use Sortable Components in many ways. For example, we can have Sortable containers that contain sortable lists, allowing users to sort containers, list items, and drag list items between containers:

<SortableMultiDnd />

To handle this use case, DnD-Kit exposes a set of presets from the `@dnd-kit/sortable` package:

1. The `useSortable` hook - A react hook which makes HTML elements sortable. The hook is a combination of the `useDraggable` and `useDroppable` hooks.
2. The `SortableContext` - An additional context provider which manages the interactions between sortable components.

Let's now explore how to use the primitives and presets to create various drag-and-drop interactions.

## Examples

We'll be looking at four common types of drag and drop interactions:

1. **Free Drag-and-Drop** - Drag elements across the entire screen, similar to apps such as Figma and Excalidraw.
2. **Droppable Containers** - Drag multiple draggable components into one or more designated areas.
3. **Single Container Sortable List** - A list within one container that rearranges items as they are dragged.
4. **Multi-Container Sortable List** - A sortable list with items that can be dropped and sorted into multiple containers.

### Free Drag-and-Drop

A user interface allows users to pick up and drag an element across the entire viewport.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
First, we create a `Draggable` Component with the `useDraggable` hook.  This component takes a unique `id`, and a `styles` object as props:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id,
  });

  return (
    <div
      //Sets up the draggable element
      ref={setNodeRef}
      style={{
        ...styles,
        //Updates the position of the draggable element as it is dragged
        transform: CSS.Translate.toString(transform),
      }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our `Draggable` components. We'll be storing the data about our `Draggable` components as an array of objects in state.

Each object should include a unique `id` and the initial `x` and `y` position coordinates of our `Draggable` components:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  //The state of our draggable elements
  const [draggables, setDraggables] = React.useState([
    {
      id: "DG",
      name: "D",
      position: {
        x: 24,
        y: 24,
      },
    },
    {
      id: "KA",
      name: "K",
      position: {
        x: 164,
        y: 164,
      },
    },
  ]);

  //sensors are used to detect drag events see more at https://docs.dndkit.com/api-documentation/sensors
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext sensors={sensors}>
      {draggables.map((d) => (
        <Draggable
          {...d}
          key={d.id}
          //We pass the current position of the draggbale here ass CSS styles
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

We'll use the `onDragEnd` event emitted by the DndContext to update the positions of our components when a drag event ends. This event contains the `x` and `y` positions of the active `Draggable` component when it is dropped.

In our handler function, we can access this information to update the component's position in state.

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  const [draggables, setDraggables] = React.useState([...draggable]);

  //Handler function to respond to an onDragEnd event
  function handleDragEnd(ev: DragEndEvent) {
    const { active } = ev;

    //if there is no active draggable, return
    if (!active) return;

    //find the active draggable in state
    const draggable = draggables.find((x) => x.id === ev.active.id);

    //update the position of the active draggable
    draggable.position.x += ev.delta.x;
    draggable.position.y += ev.delta.y;

    setDraggables((draggables) =>
      //update the state of the active draggable with the new position
      draggables.map((d) => (d.id === draggable.id ? draggable : d))
    );
  }

  return (
    <DndContext onDragEnd={handleDragEnd} sensors={sensors}>
      {draggables.map((d) => (
        <Draggable
          key={d.id}
          id={d.id}
          name={d.name}
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

</Callout>

### Droppable Containers

A user interface allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
We need `Draggable` and `Droppable` components to build this. The draggable component is similar to the one we made in the free DnD example.

To create a droppable component, we'll use the `useDropabale` hook. This component takes a unique `id` as props, similar to the `Draggable` component:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: id,
  });

  return (
    <div
      ref={setNodeRef}
      style={{
        //Conditional styles to indicate when a draggable is over a droppable area
        color: isOver ? "gray" : undefined,
      }}
    >
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragOverEvent,
} from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export default function App() {
  //set up state for draggable and droppable components
  //The state is an object where the keys are the ids of the droppable components
  //and the values are an array of draggable components that are currently in the droppable area
  const [items, setItems] = React.useState({
    A: [
      {
        id: "KV9DAsrRh2",
        name: "AQ",
      },
      {
        id: "KDVGlBlDXX",
        name: "CO",
      },
    ],
    B: [
      {
        id: "wXl_8K1JaC",
        name: "BL",
      },
      {
        id: "3MF7jrHKqd",
        name: "JA",
      },
    ],
  });

  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      onDragOver={handleDragOver}
      //optimised collision detection see https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms for more info
      collisionDetection={closestCorners}
    >
      {/** map over the object in state and render a droppable component for each item */}
      <div className="app">
        {Object.entries(items).map(([key, value]) => (
          <Droppable key={key} id={key}>
            {value.map((item) => (
              //render a draggable component for each item in the droppable container
              <Draggable key={item.id} id={item.id} name={item.name} />
            ))}
          </Droppable>
        ))}
      </div>
    </DndContext>
  );
}
```

To allow our draggable components to move between containers, we need a helper function, `findContainer`, which takes an `id` and returns the relevant droppable container id.

We use this helper function in our `handleDragEnd` function to find the items in the active and over containers in response to the `onDragEnd` event and update them in state:

```tsx
function findContainer(id: string) {
  //if the id is a key in the items object, that means it is a droppable container
  if (id in items) {
    return id;
  }

  //if the id is not a key in the items object, that means it is a draggable item and we need to find the container it is in
  //we can do this by looping over the items object and checking if the id is in the array of items
  return Object.keys(items).find((key) => {
    return items[key].some((item) => item.id === id);
  });
}

function handleDragOver(ev: DragOverEvent) {
  const { active, over } = ev;

  //if there is no active draggable or no droppable container, return
  if (!over || !active) {
    return;
  }
  const activeId = active.id;
  const overId = over?.id;

  //find the active and over containers
  const activeContainer = findContainer(activeId);
  const overContainer = findContainer(overId);

  //if there is no active container or no over container, or if the active container is the same as the over container, no need to update state so return
  if (!activeContainer || !overContainer || activeContainer === overContainer) {
    return;
  }

  setItems((items) => {
    //find the active item and the items in the active and over containers
    const activeItems = items[activeContainer];
    const overItems = items[overContainer];
    const activeItem = activeItems.find((item) => item.id === activeId);

    //update the items in state
    const newItems = {
      ...items,
      //remove the active item from the active container
      [activeContainer]: activeItems.filter((item) => item.id !== activeId),
      //add the active item to the over container
      [overContainer]: [...overItems, activeItem],
    } as Items;

    return newItems;
  });
}
```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<SortableDndSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
First we create a SortableItem Component with the `useSortable` hook.  This component takes a unique `id`, and a `name`  as `props`:

```tsx
import { CSS } from "@dnd-kit/utilities";
import { useSortable } from "@dnd-kit/sortable";
import { DragHandleDots2Icon } from "@radix-ui/react-icons";

type SortableItemProps = {
  id: string;
  name?: string;
};

export function SortableItem(props: SortableItemProps) {
  const { name, id } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: id,
  });

  //set up the transform and transition styles for the draggable component
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }}>
      {/** add the drag handle */}
      <DragHandleDots2Icon
        className="drag-handle"
        {...listeners}
        {...attributes}
      />
      <span>{name}</span>
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our sortable component:

```tsx
import type { DragEndEvent } from "@dnd-kit/core";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import React from "react";
import { SortableItem } from "./SortableItem";

//set up the initial items
const initialItems = [
  {
    id: "dnuannvBxx",
    name: "GOLD",
  },
  {
    id: "mrY2amrFiv",
    name: "BRONZE",
  },
  {
    id: "Y7UE3g7kD2",
    name: "APRICOT",
  },
  {
    id: "kZ9B3D_JyO",
    name: "BEIGE",
  },
];

export default function App() {
  const [sortables, setSortables] = React.useState([...initialItems]);
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      collisionDetection={closestCenter}
      sensors={sensors}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={sortables}
        //sorting strategy suited for vertical lists see https://docs.dndkit.com/presets/sortable#sorting-strategies for more
        strategy={verticalListSortingStrategy}
      >
        <div className="app">
          {sortables.map((s) => (
            <SortableItem key={s.id} {...s} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );
}
```

Finally, we need to handle the `onDragEnd` event:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  //if there is no active draggable or no droppable container, return
  if (!over || !active) return;
  const activeId = active.id;
  const overId = over?.id;

  if (activeId && overId && active.id !== over.id) {
    setSortables((items) => {
      //find the index of the active and over items and use arrayMove to update the items in state
      const oldIndex = sortables.findIndex((f) => f.id === activeId);
      const newIndex = sortables.findIndex((f) => f.id === overId);
      return arrayMove(items, oldIndex, newIndex);
    });
  }
}
```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<SortableMultiDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
  We are going to need a `SortableItem`  and `SortableContainer` components to build this. The `SortableItem` component is identical to the one we made in the Single Container Sortables example above. 
  
  The `SortableContainer` is quite similar as well, the only diffrence is that we need to add an empty droppable container to the `SortableContainer` component when it has no items:

```tsx
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Item } from "./items";
import { CSS } from "@dnd-kit/utilities";
import { useDroppable } from "@dnd-kit/core";
import { SortableItem } from "./SortableItem";

type SortableContainerProps = {
  id: string;
  name?: string;
  items: Item[];
};

type DroppableProps = {
  id: string;
  children?: React.ReactNode;
  className?: string;
};

export function Droppable(props: DroppableProps) {
  const { id, children, className } = props;

  const { setNodeRef } = useDroppable({
    id,
  });

  return (
    <div ref={setNodeRef} className={className}>
      {children}
    </div>
  );
}

export function SortableContainer(props: SortableContainerProps) {
  const { name, id, items } = props;
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({
      id: id,
      data: { name, type: "container" },
    });
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }} className="sortable-container">
      <div>
        <div
          {...listeners}
          {...attributes}
          className="sortable-container_header"
        >
          {name}
        </div>
        {/** if there are no items in the container, render an empty droppable container with the same id as the SortableContainer */}
        {items.length === 0 ? (
          <Droppable id={id} key={id} className="droppable">
            List is empty
          </Droppable>
        ) : (
          <SortableContext items={items} strategy={verticalListSortingStrategy}>
            {items.map((s) => (
              <SortableItem {...s} key={s.id} />
            ))}
          </SortableContext>
        )}
      </div>
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our items and containers:

```tsx
import {
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragEndEvent,
  DragOverEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  horizontalListSortingStrategy,
  SortableContext,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable";
import React from "react";
import { SortableContainer } from "./SortableContainer";

//initial items
export const initialItems = [
  {
    id: "A",
    name: "Container A",
    //helper function to create an array of draggbale items
    items: createData(3, (index) => `ITEM A${index + 1}`),
  },
  {
    id: "B",
    name: "Container B",
    //helper function to create an array of draggbale items
    items: createData(2, (index) => `ITEM B${index + 1}`),
  },
];

export default function App() {
  //state of the items
  const [sortables, setSortables] = React.useState([...initialItems]);

  //rembmber to set up your sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      collisionDetection={closestCorners}
      sensors={sensors}
      //we will implment the handlers below
      onDragEnd={handleDragEnd}
      onDragOver={handleDragOver}
    >
      <SortableContext
        items={sortables}
        strategy={horizontalListSortingStrategy}
      >
        {sortables.map((s) => (
          <SortableContainer
            key={s.id}
            id={s.id}
            name={s.name}
            items={s.items}
          />
        ))}
      </SortableContext>
    </DndContext>
  );
}
```

Now we can implement the `onDragOver` handler. This handler will be called when a draggable item is dragged over a droppable container. We will use this handler to update the state of the items and containers when a draggable item is dragged over a droppable container. We have two helper function to help us with this:

- `findContainer` - finds the active or over container based on the id of the active or over item. If the active or over item is a container, it will return the id of the container. If the active or over item is an item inside a container, it will return the id of the container that the item is inside.
- `isSortingContainers` - Returns true if the active and over items are both containers. If this is true we know we are sorting the containers and not the items inside the containers.

```tsx
function findContainer(id?: string) {
  if (id) {
    const container = sortables?.find((i) =>
      i.items?.find((l) => l?.id === id)
    );

    return container?.id;
  }
}

function isSortingContainers(activeId: string, overId: string) {
  return (
    sortables.map((s) => s.id).includes(overId) &&
    sortables.map((s) => s.id).includes(activeId)
  );
}

function handleDragOver(event: DragOverEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!over || !activeId || !overId) return;
  const activeContainerId = findContainer(activeId);
  const overContainerId = findContainer(overId);

  //If there is no active container or over container, return early
  if (!overContainerId || !activeContainerId) return;

  //In this example we can not drag a container over another container, is if we are sorting the containers
  //we will return early and not update the state
  if (isSortingContainers(activeId, overId)) return;

  //Only update state when the active container is not the same as the over container
  if (activeContainerId !== overContainerId) {
    //Find active and over items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const overContainer = sortables.find((i) => i.id === overContainerId);
    const activeItems = activeContainer?.items || [];
    const activeIndex = activeItems.findIndex((i) => i.id === active.id);
    const overItems = overContainer?.items || [];
    const overIndex = sortables.findIndex((i) => i.id === over.id);

    //Need to find the newindex to insert the active item into the over container
    let newIndex: number;
    //check if container is empty, if it is we will add the active item to the end of the container
    if (sortables.map((s) => s.id).includes(over.id as string)) {
      newIndex = overItems.length + 1;
    } else {
      //if the container is not empty we will check if the active item is below the over item and update the index accordingly
      const isBelowOverItem =
        over &&
        active.rect.current.translated &&
        active.rect.current.translated.top > over.rect.top + over.rect.height;
      const modifier = isBelowOverItem ? 1 : 0;
      newIndex = overIndex >= 0 ? overIndex + modifier : overItems.length + 1;
    }

    const newItems = sortables.map((item) =>
      // Remove the active item from the old container
      item.id === activeContainerId
        ? {
            ...item,
            items: activeItems.filter((item) => item.id !== active.id),
          }
        : // Add the active item to the new container at the new index
        item.id === overContainerId
        ? {
            ...item,
            items: [
              ...item.items.slice(0, newIndex),
              activeItems[activeIndex],
              ...overItems.slice(newIndex, item.items.length),
            ],
          }
        : item
    );

    //update the state
    setSortables(newItems);
  }
}
```

Now we can implement the `onDragEnd` handler. This handler will be called when a draggable item is dropped. We will use this handler to update the state of the items and containers when a draggable item is dropped. We will be using our helper functions here as well:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!activeId || !overId) return;
  const activeContainerId = findContainer(activeId);

  //If we are sorting the containers, we will update the state to reflect the new order of the containers
  if (isSortingContainers(activeId, overId)) {
    if (activeId !== overId) {
      setSortables((items) => {
        const oldIndex = sortables.findIndex((f) => f.id === activeId);
        const newIndex = sortables.findIndex((f) => f.id === overId);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  } else {
    //Update the state to reflect the new order of the items inside the containers, iuf we are sorting the items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const activeItems = activeContainer?.items || [];
    const oldIndex = activeItems.findIndex((i) => i.id === activeId);
    const newIndex = activeItems.findIndex((i) => i.id === overId);
    const newItems = sortables.map((s) =>
      //Find the active container and update the items inside the container
      s.id === activeContainerId
        ? {
            ...s,
            items: arrayMove(s.items, oldIndex, newIndex),
          }
        : s
    );

    //Only update the state if the active item has moved
    if (oldIndex !== newIndex) {
      setSortables(newItems);
    }
  }
}
```

</Callout>

## Closing Thoughts

I hope I managed to demonstrate the power of DndKit. Its strength lies in its flexibility. You can use it to create anything from a simple to-do list to a complex drag-and-drop interface.

I hope you enjoyed this post. If you have any questions, you can reach me on Twitter [@kxlaa\_](https://twitter.com/kxlaa_) and I'll be happy to answer them. You can also check out the [DndKit](https://dndkit.com/) website for more examples and documentation.

Thank you for reading and happy coding!
