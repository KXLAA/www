---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is an awesome library I recently discovered while working on the new dashboard at [Super](https://super.so/). It simplifies the complex task of creating performant Drag-and-Drop UI interactions, with some interesting patterns and concepts. I spent some time creating a lot of cool interactions with the library and wanted to share some of the things I learned.

If you're already familiar with DnD Kit, or just want to see code examples, jump straight to them [here](#examples). Otherwise, keep reading to learn more about the library and how to get started.

Let's begin!

<Callout intent="info" heading="Intended Audience" dropdown>
  This article assumes you have a basic understanding of React and Typescript.
  If you're new to React, I recommend reading
  [this](https://reactjs.org/docs/getting-started.html) and
  [this](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup/). If
  you're new to Typescript, I recommend reading
  [this](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html).
</Callout>

## Core Concepts

From a high-level, most drag-and-drop UI interactions involve three main elements: a draggable component, a droppable area, and a system that manages the interaction between them. The draggable element can be dragged, and the drop area is where it can be dropped. To gain a better understanding of how these components work, you can try out the demo below:

<FreeDnd />

In the demo above, the droppable area covers the entire page, allowing us to drop draggable elements anywhere. This is similar to canvas-based applications like Figma and Excalidraw. But we can also have fixed, designated drop areas, like this:

<DroppableDnd />

DndKit is built around this approach, offering three core primitives:

- The `useDraggable` hook, which turns DOM elements into draggable sources that can be picked up, dragged, and dropped over droppable areas.
- The `useDroppable` hook, which sets up DOM elements as droppable areas that draggable elements can be dropped over; and
- The `<DndContext />` component, which manages the interaction between draggable and droppable components via React Context API.

<Callout intent="info" heading="The React Context API">
  The React Context API is a way to share data between components without having
  to pass props down manually at every level. You can read more about it
  [here](https://reactjs.org/docs/context.html).
</Callout>

These primitives are exported from the `@dnd-kit/core` package; you can install it by running:

```shell
yarn add @dnd-kit/core
```

Let's go over each of them in detail.

### Draggable

Creating a draggable component is easy with the useDraggable hook. It takes an input object as an argument, which must include a unique id. It returns an object with several properties. We are currently interested in four of these properties:

1. `setNodeRef` - A callback `ref` we attach to the HTML element we want to make draggable. This is an essential part of how we provide dndkit with the element that needs to be dragged.
2. `listeners` - An object we spread on the HTML element that we want to use as triggers to start dragging. We can use this to create drag handles for our draggable elements.
3. `attributes` - An object with sensible defaults for accessibility that can be spread on the activator HTML element, along with the `listeners` object.
4. `transform` - An object with the x- and y-coordinates of a draggable element in 2D, which is updated as it is being dragged. We'll use this to update the CSS `translate` property, allowing us to move the draggable component on the screen.

<Callout intent="info" heading="Callback Refs">
  Callback refs are a way to access DOM nodes in React. You can read more about
  them [here](https://reactjs.org/docs/refs-and-the-dom.html#callback-refs).
</Callout>

Here is an example of how all these elements work together to create a draggable component:

```tsx
import { useDraggable } from "@dnd-kit/core";
//CSS helper for generating CSS transform strings
import { CSS } from "@dnd-kit/utilities";

function Draggable() {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "unique-id",
  });

  const transformStyle = {
    transform: CSS.Transform.toString(transform),
  };

  return (
    <button
      ref={setNodeRef}
      style={{ ...transformStyle }}
      {...listeners}
      {...attributes}
    >
      {/* Render whatever you like within */}
    </button>
  );
}
```

### Droppables

The `useDroppable` hook sets up HTML elements as droppable areas. It takes an input object with a required unique id as an argument and returns an object with several properties. We are currently interested in two of these properties:

1. `setNodeRef` - a callback `ref` we attach to the HTML element we want to make droppable. This is how we tell DndKit that an element is a drop area.
2. `isOver` - a Boolean that indicates whether a draggable component is over the droppable area. We can use this to conditionally style droppable areas.

```tsx
import { useDroppable, isOver } from "@dnd-kit/core";

function Droppable() {
  const { setNodeRef } = useDroppable({
    id: "unique-id",
  });

  return <div ref={setNodeRef}>{/* Render whatever you like within */}</div>;
}
```

### DndContext

The `<DndContext>` component manages the interactions between our draggable and droppable components. To make sure they work properly, we must wrap them within the `<DndContext>` component:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";

function App() {
  return (
    <DndContext>
      <Draggable />
      <Droppable />
    </DndContext>
  );
}
```

The `<DndContext>` provides many props to configure the behaviour of our draggable and droppable components. For a full API reference, please refer to the documentation. The most important props at this point are the `events` and `sensors` props.

#### Events

The `<DndContext>` emits various events during different stages of drag-and-drop interaction. We can use this information to configure the behaviour of draggable and droppable components. The main events are:

- `onDragStart`, which fires when a draggable is dragged and contains an object with information about the active draggable element.
- `onDragOver`, which fires when a draggable item is dragged over a droppable area. It contains an object with information about the droppable area and the draggable element.
- `onDragEnd`, which fires after a draggable item is dropped. It includes information on the active draggable `id` and whether the draggable item was dropped over a droppable area.
- `onDragCancel`, which fires if a drag operation is cancelled, e.g. if the user presses `escape` while dragging a draggable item.

We can handle these events with functions, using the event data to update the state of our draggable and droppable components in the UI. This gives us great flexibility.

To visualise when the `<DndContext>` emits different events, play around with the demo below:

<DroppableDnd />

#### Sensors

With the many devices that can access the web, there are various input types that could trigger a drag event. These include a mouse, touchpad, keyboard, stylus pen, or a touchscreen. To detect these potential input types, Dndkit exposes the concept of sensors.

Sensors provide `DndContext` with a way to detect the different stages of a drag event triggered by specific input types. By default, `@dnd-kit/core` ships with four sensors: `MouseSensor`, `TouchSensor`, `KeyboardSensor`, and `PointerSensor`. These sensors are generally enough for most use cases. However, if they are not sufficient, you can build a custom sensor. For more information on this, check [here](https://docs.dndkit.com/api-documentation/sensors#custom-sensors).

By default, `DndContext` uses the Pointer and Keyboard sensors. To use other sensors, such as the Mouse and Touch sensors, initialize them separately using the `useSensor` hook:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";

function App() {
  const sensors = useSensors(
    useSensor(MouseSensor),
    useSensor(TouchSensor),
    useSensor(KeyboardSensor)
  );

  return <DndContext sensors={sensors}>{/* ... */}</DndContext>;
}
```

## Examples

Now that we've discussed the core concepts of dndkit, let's explore examples of how to use them to create various drag-and-drop interactions. We'll cover four common types:

- Free Drag-and-Drop
- Droppable Containers
- Single Container Sortable list
- Multi-Container Sortable list

### Free Drag-and-Drop

A user interface allows users to pick up and drag an element across the entire viewport.

<FreeDnDSandPack />

<Dropdown heading='Code Breakdown'>
In this interaction, we have multiple draggable components. To build this, we need to create a Draggable Component with the useDraggable hook. This component takes a unique id, and a styles object as props:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

//First create a draggable component
type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform, isDragging } =
    useDraggable({
      id,
    });

  const transformStyles = transform
    ? {
        transform: CSS.Translate.toString(transform),
      }
    : {};

  return (
    <div
      ref={setNodeRef}
      style={{ ...transformStyles, ...styles }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next we need to set up our DndContext and the state of our Draggable components. We'll be storing the data about our draggable components as an array of objects in state. Each object should include a unique ID and the initial x and y position coordinates of the element:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  //initial draggble state
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

To allow our components to be moved around the page, we need to update their positions when a drag event ends. We'll use the `onDragEnd` event emitted by the `<DndContext />` to do this. This event contains the x- and y-positions of the active draggable element when it is dropped. In our handler function, we can use this information to update the position of our element in state:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

//Create a handler function to respond to an ondragend event & update the position of the draggable element
export function App() {
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  function handleDragEnd(ev: DragEndEvent) {
    const activeId = ev.active.id;

    //if there is no active draggable return
    if (!activeId) {
      return;
    }

    //find active draggable in state and update its position
    const draggable = draggables.find((x) => x.id === ev.active.id);
    draggable.position.x += ev.delta.x;
    draggable.position.y += ev.delta.y;
    const _draggables = draggables.map((d) =>
      d.id === draggable.id ? draggable : d
    );

    setDraggables(_draggables);
  }

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

</Dropdown>

### Droppable Containers

A user interface allows users to pick up and drag an element into designated droppable areas

<FreeDnDSandPack />

<Dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Dropdown>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<FreeDnDSandPack />

<Dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Dropdown>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<FreeDnDSandPack />

<Dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Dropdown>

## Closing Thoughts
