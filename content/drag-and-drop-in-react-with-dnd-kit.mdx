---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is an awesome library I recently discovered while working on the new dashboard at [Super](https://super.so/). It simplifies the complex task of creating performant Drag-and-Drop UI interactions, with some interesting patterns and concepts. In this post, I want to share some of the things I learned.

If you're already familiar with DnD Kit, or just want to take a look at the code examples, you can jump straight to them [here](#examples). Otherwise, you can keep reading to learn more about the library and how to get started.

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

Drag-and-drop interactions on the web typically involve three elements:

- a **draggable component** that can be dragged,
- a **droppable area** where draggable components can be dropped over, and
- a **system that manages** the interaction between the draggable components and the droppable areas.

To see these elements in action, you can play with the demo below:

<FreeDnd />

In the demo, we can move our draggable components anywhere on the page. However, we can also specify particular areas that are droppable, so that users can only drag the components within those areas:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives:

1. The `useDraggable` hook - A React hook which makes HTML elements draggable.
2. The `useDroppable` hook - A React hook which makes HTML elements droppable areas.
3. The `DndContext` - A context provider which manages the interaction between draggable and droppable components using the React Context API.

The @dnd-kit/core package exports these primitives; install it by running this:

```shell
yarn add @dnd-kit/core
```

In more advanced types of drag-and-drop UI interactions, we also have sortable components. These are usually used in lists, where each list item is both draggable and droppable. When you drag a list item, it automatically sorts with the other list items in the list:

<SortableDnd />

The sortable characteristic is not limited to just list items; the lists themselves can also be sortable:

<SortableMultiDnd />

To handle this use case, DnD-Kit exposes a set of presets from the `@dnd-kit/sortable` package:

1. The `useSortable` hook - A react hook which makes HTML elements sortable. The hook is a combination of the `useDraggable` and `useDroppable` hooks.
2. The `SortableContext` - An additional context provider which manages the interactions between sortable components.

Install the presets by running:

```shell
yarn add @dnd-kit/sortable
```

Let's discuss these primitives and presets in more detail.

### Draggable

We can make draggable components easily with the `useDraggable` hook. This hook takes an input object with a required `id` as an argument and returns an object with several properties. We are currently interested in four of these properties:

1. `setNodeRef` - A callback `ref` we attach to the HTML element we want to make draggable. This is essential for providing DndKit with the element that needs to be dragged.
2. `listeners` - An object we spread on the HTML element that we use as a trigger or activator to start a drag event. We can use this to create drag handles for our draggable elements.
3. `attributes` - An object with sensible defaults for accessibility. We spread this object on the activator HTML element, along with the `listeners` object.
4. `transform` - An object with the x- and y-coordinates of a draggable element in 2D, which is updated during a drag event. We can use the values of the object to update the position of our draggable element with CSS.

<Callout intent="info" heading="Callback Refs">
  Callback refs are functions that receive a reference to a rendered HTML
  element as an argument. It is a way to access HTML elements directly in React.
  Learn more about them
  [here](https://julesblom.com/writing/ref-callback-use-cases).
</Callout>

Here is an example of how all these elements come together to create a draggable component:

```tsx
import { useDraggable } from "@dnd-kit/core";
//CSS helper for generating CSS transform strings
import { CSS } from "@dnd-kit/utilities";

function Draggable() {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "unique-id",
  });

  const style = {
    transform: CSS.Transform.toString(transform),
  };

  return (
    <button
      ref={setNodeRef}
      style={{ ...style }}
      {...listeners}
      {...attributes}
    >
      {/* Render whatever you like within */}
    </button>
  );
}
```

You can view the full API reference of the `useDraggable` hook [here](https://docs.dndkit.com/api-documentation/draggable/usedraggable) in the documentation.

<Callout intent="info" heading="What are Drag Handles ?" dropdown>
Drag handles are HTML elements that trigger a drag event. In our draggable component, we set the draggable source (i.e., the <code>div</code> we attached the  <code>setNodeRef</code> callback to) to act as the drag handle.

However, we can make a different HTML element the drag handle by attaching the listeners and attribute properties returned by the <code>useDraggable</code> hook to it:

```tsx
import { useDraggable } from "@dnd-kit/core";

function Draggable() {
  const { attributes, listeners, setNodeRef } = useDraggable({
    id: "unique-id",
  });

  return (
    <div ref={setNodeRef}>
      {/* Some other content that does not activate dragging */}
      <button {...listeners} {...attributes}>
        Drag handle
      </button>
    </div>
  );
}
```

</Callout>

### Droppable

The `useDroppable` hook sets up HTML elements as droppable areas. It takes an input object with a required `id` as an argument and returns an object with several properties. We are currently interested in two of these properties:

1. `setNodeRef` - a callback ref we attach to the HTML element we want to make droppable. This is how DndKit knows an element is a drop area.
2. `isOver` - a boolean that indicates whether a draggable component is over a droppable area. We can use this to style droppable areas conditionally.

Here is how all these elements come together to create a droppable component:

```tsx
import { useDroppable } from "@dnd-kit/core";

function Droppable() {
  const { setNodeRef, isOver } = useDroppable({
    id: "unique-id",
  });

  return (
    <div
      ref={setNodeRef}
      style={{
        // Change the bg color when a draggable component is over the droppable area
        backgroundColor: isOver ? "red" : "blue",
      }}
    >
      {/* Render whatever you like within */}
    </div>
  );
}
```

You can view the full API reference of the `useDroppable` hook [here](https://docs.dndkit.com/api-documentation/droppable/usedroppable) in the documentation.

### DndContext

The `DndContext` manages interactions between draggable and droppable components. To enable this, we need to wrap all draggable and droppable components within it:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";

function App() {
  return (
    <DndContext>
      <Draggable />
      <Droppable />
    </DndContext>
  );
}
```

The `DndContext` provides many props to configure the behaviour of our draggable and droppable components. For a full API reference, please refer to the [documentation](https://docs.dndkit.com/api-documentation/context-provider). Two of the most important ways to customise the behaviour of our components are through **sensors** and **events**.

#### Events

The `DndContext` emits various events throughout a drag-and-drop interaction:

- At the start of a drag event, the `onDragStart` event is triggered. This event provides information about the element that is being dragged, like its ID.
- When a draggable component is dragged, the `onDragOver` event will fire, which contains information about the draggable element and the droppable area it was stopped over.
- At the end of a drag event, the `onDragEnd` event is triggered. This event includes information about the dropped draggable item and if it was over a droppable container when dropped.
- When a drag event is cancelled, for example when the user presses `escape` while dragging a draggable item, the `onDragCancel` event is triggered.

We can use handler functions to respond to these events. Using the information they contain, we can update the state of our draggable and droppable components in the UI.

#### Sensors

Dndkit exposes the concept of sensors to detect input types that can trigger a drag event. Four sensors are included in `@dnd-kit/core`: `MouseSensor`, `TouchSensor`, `KeyboardSensor`, and `PointerSensor`. These are enough for most use cases, but you can build a custom sensor if these are not enough. For more information, see the [documentation](https://docs.dndkit.com/api-documentation/sensors#custom-sensors).

By default, the `DndContext` uses the `Pointer` and `Keyboard`. To leverage the `Mouse` and `Touch` sensors, we need to invoke the `useSensor` hook:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";

function App() {
  const sensors = useSensors(
    useSensor(MouseSensor),
    useSensor(TouchSensor),
    useSensor(KeyboardSensor)
  );

  return <DndContext sensors={sensors}>{/* ... */}</DndContext>;
}
```

### Sortables

The `useSortable` hook is similar to `useDraggable` and can be used to create Sortable components:

```tsx
import React from "react";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";

type SortableItemProps = {
  id: string;
  heading: string;
};

export function SortableItem(props: SortableItemProps) {
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({ id: props.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={style} {...attributes} {...listeners}>
      <h3>{props.heading}</h3>
    </div>
  );
}
```

In addition to the `useSortable` hook, we also have the `SortableContext`. This component manages interactions between sortable components. To set it up correctly, we need to pass it an array of all the unique `id’s` of our sortable components in the `items` prop:

```tsx
import React from "react";
import { DndContext } from "@dnd-kit/core";
import { SortableContext } from "@dnd-kit/sortable";
import { SortableItem } from "./SortableItem";

function App() {
  const [items, setItems] = React.useState([
    {
      id: "sortable-1",
      heading: "Sortable 1",
    },
    {
      id: "sortable-2",
      heading: "Sortable 2",
    },
    {
      id: "sortable-3",
      heading: "Sortable 3",
    },
  ]);

  return (
    <DndContext>
      <SortableContext items={items.map((i) => i.id)}>
        {items.map((i) => (
          <SortableItem key={i.id} {...i} />
        ))}
      </SortableContext>
    </DndContext>
  );
}
```

## Examples

Now that we've discussed DndKit's core concepts, let's explore how to use them to create different drag-and-drop interactions. We'll look at four common types:

- Free Drag-and-Drop
- Droppable Containers
- Single Container Sortable list
- Multi-Container Sortable list

### Free Drag-and-Drop

A user interface allows users to pick up and drag an element across the entire viewport.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
  First we create a Draggable Component with the useDraggable hook.  This component takes a unique `id`, and a `styles` object as `props`:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

//First create a draggable component
type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id,
  });

  const transformStyles = transform
    ? {
        transform: CSS.Translate.toString(transform),
      }
    : {};

  return (
    <div
      ref={setNodeRef}
      style={{ ...transformStyles, ...styles }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next we need to set up our DndContext and the state of our Draggable components. We'll be storing the data about our draggable components as an array of objects in state.

Each object should include a unique `id` and an initial `x` and `y` position coordinates for the draggable component:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

//initial draggble state
const draggable = [
  {
    id: "DG",
    name: "D",
    position: {
      x: 24,
      y: 24,
    },
  },
  {
    id: "KA",
    name: "K",
    position: {
      x: 164,
      y: 164,
    },
  },
];

export function App() {
  const [draggables, setDraggables] = React.useState([...draggable]);

  return (
    <DndContext>
      {draggables.map((d) => (
        <Draggable
          //We pass the current position of the draggbale here ass CSS styles
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
          key={d.id}
          id={d.id}
          name={d.name}
        />
      ))}
    </DndContext>
  );
}
```

To allow our components to be moved around the page, we need to update their positions when a drag event ends. We'll use the `onDragEnd` event emitted by the `<DndContext />` to do this. This event contains the x- and y-positions of the active draggable element when it is dropped.

In our handler function, we can use this information to update the position of our element in state:

```tsx
//Set up DndContext and the state of our draggable elements
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  const [draggables, setDraggables] = React.useState([...draggable]);
  //remember to add the sensors to the DndContext
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  //Handler function to respond to an onDragEnd event
  function handleDragEnd(ev: DragEndEvent) {
    const { active } = ev;

    //if there is no active draggable, return
    if (!active) return;

    //find the active draggable in state
    const draggable = draggables.find((x) => x.id === ev.active.id);

    //update the position of the active draggable
    draggable.position.x += ev.delta.x;
    draggable.position.y += ev.delta.y;

    setDraggables((draggables) =>
      //update the state of the active draggable
      draggables.map((d) => (d.id === draggable.id ? draggable : d))
    );
  }

  return (
    <DndContext onDragEnd={handleDragEnd} sensors={sensors}>
      {draggables.map((d) => (
        <Draggable
          key={d.id}
          id={d.id}
          name={d.name}
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

</Callout>

### Droppable Containers

A user interface allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
  We are going to need draggable and droppable components to build this. The draggable component is similar to the one we made in the free DnD example above. 
  
  To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique `id` as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  //Conditional styles to indicate when a draggable is over a droppable area
  const style = {
    color: isOver ? "gray" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragOverEvent,
} from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

//initial draggble state
const items: Items = {
  A: [
    {
      id: "KV9DAsrRh2",
      name: "AQ",
    },
    {
      id: "KDVGlBlDXX",
      name: "CO",
    },
  ],
  B: [
    {
      id: "wXl_8K1JaC",
      name: "BL",
    },
    {
      id: "3MF7jrHKqd",
      name: "JA",
    },
  ],
};

export default function App() {
  //set up state for draggable and droppable components
  const [items, setItems] = React.useState(defaultItems);

  //remember to add the sensors to the DndContext
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      //see below
      onDragOver={handleDragOver}
      //optimised collision detection see https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms for more info
      collisionDetection={closestCorners}
    >
      {/** map over the object in state and render a droppable component for each item */}
      <div className="app">
        {Object.entries(items).map(([key, value]) => (
          <Droppable key={key} id={key}>
            {value.map((item) => (
              //render a draggable component for each item in the droppable container
              <Draggable key={item.id} id={item.id} name={item.name} />
            ))}
          </Droppable>
        ))}
      </div>
    </DndContext>
  );
}
```

To allow our draggable components to move between containers, we need a helper function, `findContainer`, which takes an `id` and returns the relevant droppable container id.

We will be using this helper function in our `handleDragEnd` function to find the items in the active and over containers and update them in state:

```tsx
function findContainer(id: string) {
  //if the id is a key in the items object, that means it is a droppable container
  if (id in items) {
    return id;
  }

  //if the id is not a key in the items object, that means it is a draggable item and we need to find the container it is in
  //we can do this by looping over the items object and checking if the id is in the array of items
  return Object.keys(items).find((key) => {
    return items[key].some((item) => item.id === id);
  });
}

function handleDragOver(ev: DragOverEvent) {
  const { active, over } = ev;

  //if there is no active draggable or no droppable container, return
  if (!over || !active) {
    return;
  }
  const activeId = active.id;
  const overId = over?.id;

  //find the active and over containers
  const activeContainer = findContainer(activeId);
  const overContainer = findContainer(overId);

  //if there is no active container or no over container, or if the active container is the same as the over container, no need to update state so return
  if (!activeContainer || !overContainer || activeContainer === overContainer) {
    return;
  }

  setItems((items) => {
    //find the active item and the items in the active and over containers
    const activeItems = items[activeContainer];
    const overItems = items[overContainer];
    const activeItem = activeItems.find((item) => item.id === activeId);

    //update the items in state
    const newItems = {
      ...items,
      //remove the active item from the active container
      [activeContainer]: activeItems.filter((item) => item.id !== activeId),
      //add the active item to the over container
      [overContainer]: [...overItems, activeItem],
    } as Items;

    return newItems;
  });
}
```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<SortableDndSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<SortableMultiDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Callout>

## Closing Thoughts
