---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is a relatively new, hook-based library that makes it easy to create performant and accessible drag-and-drop UI interactions in React. I have been using the library a lot at Super, particularly in our new dashboard, and I wanted to share some examples of the kind of interactions that can be built with it.

In this post, I will provide a brief overview of the core concepts behind `@dnd-kit` and then iâ€™ll move on to a number of [code examples](#examples) with explanations. If you need more detail about anything i cover, you can always consult the documentation here.

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

Drag-and-drop interactions on the web typically involve three elements:

- a **draggable component** that can be dragged,
- a **droppable area** where draggable components can be dropped over, and
- a **system that manages** the interaction between the draggable components and the droppable areas.

To see how these elements typically come together, you can play with the demo below:

<FreeDnd />

In the demo, we can drag our draggable components and drop them anywhere on the page. However, we can also restrict the dropping of our draggable components to particular areas:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives exported from the `@dnd-kit/core` package:

1. The [`useDraggable`](https://docs.dndkit.com/api-documentation/draggable) hook - A React hook which makes HTML elements draggable.
2. The [`useDroppable`](https://docs.dndkit.com/api-documentation/droppable) hook - A React hook which makes HTML elements droppable areas.
3. The [`DndContext`](https://docs.dndkit.com/api-documentation/context-provider) - A context provider which manages the interaction between draggable and droppable components using the React Context API.

Drag-and-drop interactions often require more than just dragging and dropping components. For example, take a look at the demo below:

<SortableDnd />

In the demo, we have a list. When we drag a single item, it automatically sorts with its other siblings. This type of interaction is known as a sortable interface, where components are both draggable and droppable. We can refer to these components as "Sortable Components".

`Sortable` components can be used in a variety of ways. For instance, we can have multiple containers with `Sortable` list items, enabling users to sort the containers, list items, and drag items between them:

<SortableMultiDnd />

To handle this use case, ` @dnd-kit` exposes a set of presets from the `@dnd-kit/sortable` package:

1. The `useSortable` hook - A react hook which makes HTML elements sortable. The hook is a combination of the `useDraggable` and `useDroppable` hooks.
2. The `SortableContext` - An additional context provider which manages the interactions between sortable components.

Let's now explore how to use the primitives and presets to create various drag-and-drop interactions.

## Examples

We'll be looking at four common types of drag and drop interactions:

1. **Free Drag-and-Drop** - Drag draggable components across the entire page, similar to apps such as Figma and Excalidraw.
2. **Droppable Containers** - Drag multiple draggable components into one or more designated droppable containers.
3. **Single Container Sortable List** - A sortable list within a single container.
4. **Multi-Container Sortable List** - Sortable lists within multiple sortable containers.

### Free Drag-and-Drop

A user interface that allows users to pick up and drag an element across the entire page.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
First, we create a `Draggable` component with the `useDraggable` hook:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id,
  });

  return (
    <div
      //Sets up the draggable element
      ref={setNodeRef}
      style={{
        ...styles,
        //Updates the position of the draggable element as it is dragged
        transform: CSS.Translate.toString(transform),
      }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

This `Draggable` component takes a unique `id` and a `styles` object as `props`. We pass the `id` we receive as props as a field of the object we pass to the `useDraggable` hook; this `id` field in the object is required.

The `useDraggable` hook returns a number of properties. The ones we use are:

- `setNodeRef`: a callback ref we attach to the HTML element we want to make draggable (the div in the code above). This is essential for providing `@dnd-kit` with the element that needs to be dragged.
- `listeners`: an object we spread on the HTML element that serves as a trigger or activator to start a drag event.
- `attributes`: an object with sensible defaults for accessibility. We spread this object on the activator HTML element, along with the `listeners` object.
- `transform`: an object with the x- and y-coordinates of a draggable element in 2D, which is updated during a drag event. We use the values of the object to update the position of our draggable element with CSS via the `transform` property.

Next, we set up our `DndContext` and the state of our `Draggable` components:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  const [draggables, setDraggables] = React.useState([
    {
      id: "DG",
      name: "D",
      position: {
        x: 24,
        y: 24,
      },
    },
    {
      id: "KA",
      name: "K",
      position: {
        x: 164,
        y: 164,
      },
    },
  ]);

  //sensors are used to detect drag events see more at https://docs.dndkit.com/api-documentation/sensors
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      //we implement this handler below
      onDragEnd={handleDragEnd}
    >
      {draggables.map((d) => (
        <Draggable
          {...d}
          key={d.id}
          //We pass the current position of the draggables here as CSS styles
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

The state of our `Draggable` components is represented in an array of objects. Each object contains an `id`, `name`, and the current `position` of the component. We pass the current positions in state to the `style` object's left and top CSS properties with an `absolute` position, allowing the components to be dragged across the entire area.

We need a way to update the position of our `Draggable` component while a user is dragging it. The `onDragEnd` event, emitted by `DndContext`, is triggered at the end of a drag event. It contains data such as the `position`, `id`, and more of the active `Draggable` component. We can access this data with a handler function and use it to update the `Draggable` components' positions in state:

```tsx
//Handler function to respond to an onDragEnd event
function handleDragEnd(ev: DragEndEvent) {
  const { active, delta } = ev;

  //if there is no active draggable, return
  if (!active) return;

  //find the active draggable in state
  const draggable = draggables.find((d) => d.id === active.id);

  //update the position of the active draggable
  draggable.position.x += delta.x;
  draggable.position.y += delta.y;

  setDraggables((draggables) =>
    //update the state of the active draggable with the new position
    draggables.map((d) => (d.id === draggable.id ? draggable : d))
  );
}
```

</Callout>

### Droppable Containers

A user interface that allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
For this interaction, we need a `Draggable` and `Droppable` Component. We already built the `Draggable` component [`above`](#free-drag-and-drop), so there's no need to repeat it here.

For the `Droppable` component, we will be using the `useDropabale` hook:

```tsx
import React from "react";
import { useDroppable } from "@dnd-kit/core";

type DroppableProps = {
  id: string;
  children?: React.ReactNode;
  className?: string;
};

export function Droppable(props: DroppableProps) {
  const { children, id, className } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: id,
  });

  const style = {
    background: isOver && !(id === "root") ? "#18181a" : "",
  };

  return (
    <div ref={setNodeRef} className={className} style={style}>
      {children}
    </div>
  );
}
```

This `Droppable` component takes a unique `id` and a `className` as `props`. We pass the `id` we receive as props as a field of the object we pass to the `useDroppable` hook; this `id` field in the object is required.

The `useDroppable` hook returns a number of properties. The ones we use are:

- `setNodeRef` - a callback ref we attach to the HTML element we want to make droppable. This is how `@dnd-kit` knows an element is a drop area.
- `isOver` - a boolean that indicates whether a draggable component is over a droppable area. We use this to style the droppable area conditionally.

Next, we set up our `DndContext` and the state of our `Draggable` and `Droppable` components:

```tsx
import React from "react";
import { DragOverEvent, DragStartEvent } from "@dnd-kit/core";
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  DragOverlay,
  useSensors,
} from "@dnd-kit/core";
import "./styles.css";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";
import { items as defaultItems, Item } from "./items";

function App() {
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );
  const [draggables, setDraggables] = React.useState([...defaultItems]);
  const [droppables] = React.useState(["A", "B"]);
  const [activeItem, setActiveItem] = React.useState<Item | undefined>(
    undefined
  );

  return (
    <DndContext
      sensors={sensors}
      onDragOver={handleDragOver}
      onDragStart={handelDragStart}
    >
      <div className="app">
        <div className="containers">
          {droppables.map((id) => (
            <Droppable key={id} id={id} className="droppable">
              {draggables
                .filter((draggable) => draggable.containerId === id)
                .map((draggable) => (
                  <Draggable key={draggable.id} {...draggable} />
                ))}
            </Droppable>
          ))}
        </div>
        <Droppable id="root" className="root-droppable">
          {draggables
            .filter((draggable) => draggable.containerId === "root")
            .map((draggable) => (
              <Draggable key={draggable.id} {...draggable} />
            ))}
        </Droppable>
      </div>
      <DragOverlay>
        {activeItem && (
          <div className="draggable draggable-overlay">{activeItem.name}</div>
        )}
      </DragOverlay>
    </DndContext>
  );
}
```

We have three pieces of state:

- `draggables`: an array of objects with `id`, `name`, and `containerId` fields. The `containerId` field of all `draggables` is set to `root` by default.
- `droppables`: an array of unique strings of our
- `activeItem`: the state of the active draggable, which is `undefined` by default.

We use the `draggables` & `droppables` state to render our components. If the `containerId` of a `Draggable` component is the same as the `id` of a `Droppable` component, then the `Draggable` component will be rendered as a child of the `Droppable` component.

The `DragOverlay` component provides a way to render a draggable overlay that is not part of the normal document flow and is positioned relative to the viewport. We can use this component, for instance, to show a preview of where the draggable source will be when dropped.

To render the overlay, we need details from the `Draggable` currently being dragged. We can get this information from the `onDragStart` event emitted by the `DndContext`. In the handler function, we set our state:

```tsx
function handelDragStart(ev: DragStartEvent) {
  const { active } = ev;
  const activeId = active.id;
  const activeItem = draggables.find((item) => item.id === activeId);
  setActiveItem(activeItem);
}
```

You can read more on the DragOverlay component [here](https://docs.dndkit.com/api-documentation/draggable/drag-overlay).

Finally, we need to update the state of our `Draggable` components. To do this, we'll use the `onDragOver` event emitted by the DndContext. This event is triggered when a `Draggable` is dragged over a `Droppable` area. It provides us with information about the dragged element and the droppable area it is over.

We can use this data to check which container our draggable component is over and update our state accordingly:

```tsx
function handleDragOver(ev: DragOverEvent) {
  const { active, over } = ev;
  if (!over) return;
  const activeId = active.id;
  const overId = over.id;

  setDraggables((prev) => {
    return prev.map((item) => {
      if (item.id === activeId) {
        return {
          ...item,
          containerId: overId,
        };
      }
      return item;
    });
  });
}
```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<SortableDndSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
First, we create a `SortableItem` component with the `useSortable` hook:

```tsx
import { CSS } from "@dnd-kit/utilities";
import { useSortable } from "@dnd-kit/sortable";
import { DragHandleDots2Icon } from "@radix-ui/react-icons";

type SortableItemProps = {
  id: string;
  name?: string;
};

export function SortableItem(props: SortableItemProps) {
  const { name, id } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: id,
  });

  //set up the transform and transition styles for the draggable component
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }}>
      {/** add the drag handle */}
      <DragHandleDots2Icon
        className="drag-handle"
        {...listeners}
        {...attributes}
      />
      <span>{name}</span>
    </div>
  );
}
```

The `SortableItem` component takes two props: a unique `id` and a `name`. The `id` is passed to the `useSortable` hook with an object that requires it.

The `useSortable` hook is similar to the `useDraggable` hook. In addition to what the `useDraggable` hook returns, it also provides:

- `isDragging` - A boolean set to `true` when dragging a `Sortable` component.
- `transition` - CSS animations to be applied to the `Sortable` Component.

Next, we set up our `DndContext` and the state of our `SortableItem` components:

```tsx
import React from "react";
import type { DragEndEvent } from "@dnd-kit/core";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { SortableItem } from "./SortableItem";

export default function App() {
  const [sortables, setSortables] = React.useState([
    {
      id: "dnuannvBxx",
      name: "GOLD",
    },
    {
      id: "mrY2amrFiv",
      name: "BRONZE",
    },
    {
      id: "Y7UE3g7kD2",
      name: "APRICOT",
    },
    {
      id: "kZ9B3D_JyO",
      name: "BEIGE",
    },
  ]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      //collision detection algorithm best suited for single container sortables,
      //see more at https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms
      collisionDetection={closestCenter}
      sensors={sensors}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={sortables}
        //sorting strategy suited for vertical lists
        //see https://docs.dndkit.com/presets/sortable#sorting-strategies for more
        strategy={verticalListSortingStrategy}
      >
        <div className="app">
          {sortables.map((s) => (
            <SortableItem key={s.id} {...s} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );
}
```

The state of our `SortableItem` component is a simple sorted array.

Finally, we update the positions of our sortable items at the end of the drag event using the `onDragEnd` event emitted by the `DndContext`:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  //if there is no active draggable or no droppable container, return
  if (!over || !active) return;
  const activeId = active.id;
  const overId = over?.id;

  if (activeId && overId && active.id !== over.id) {
    setSortables((items) => {
      //find the index of the active and over items and use arrayMove to update the items in state
      const oldIndex = sortables.findIndex((f) => f.id === activeId);
      const newIndex = sortables.findIndex((f) => f.id === overId);
      return arrayMove(items, oldIndex, newIndex);
    });
  }
}
```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<SortableMultiDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
We need a `SortableItem` component. This component is identical to the one we created in the single container sortable list example above, so I will omit the implementation here.

Our containers are sortable, so we create a `SortableContainer` component. This is quite similar to the `SortableItem`, but we need to add an empty `Droppable` container when it has no items:

```tsx
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Item } from "./items";
import { CSS } from "@dnd-kit/utilities";
import { useDroppable } from "@dnd-kit/core";
import { SortableItem } from "./SortableItem";

type SortableContainerProps = {
  id: string;
  name?: string;
  items: Item[];
};

type DroppableProps = {
  id: string;
  children?: React.ReactNode;
  className?: string;
};

export function Droppable(props: DroppableProps) {
  const { id, children, className } = props;

  const { setNodeRef } = useDroppable({
    id,
  });

  return (
    <div ref={setNodeRef} className={className}>
      {children}
    </div>
  );
}

export function SortableContainer(props: SortableContainerProps) {
  const { name, id, items } = props;
  const { attributes, listeners, setNodeRef, transform, transition } =
    useSortable({
      id: id,
      data: { name, type: "container" },
    });
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }} className="sortable-container">
      <div>
        <div
          {...listeners}
          {...attributes}
          className="sortable-container_header"
        >
          {name}
        </div>
        {/** if there are no items in the container, render an empty droppable container with the same id as the SortableContainer */}
        {items.length === 0 ? (
          <Droppable id={id} key={id} className="droppable">
            List is empty
          </Droppable>
        ) : (
          <SortableContext items={items} strategy={verticalListSortingStrategy}>
            {items.map((s) => (
              <SortableItem {...s} key={s.id} />
            ))}
          </SortableContext>
        )}
      </div>
    </div>
  );
}
```

Next, we set up our `DndContext` and the state of our items and containers:

```tsx
import {
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragEndEvent,
  DragOverEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  horizontalListSortingStrategy,
  SortableContext,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable";
import React from "react";
import { SortableContainer } from "./SortableContainer";

export default function App() {
  //state of the items
  const [sortables, setSortables] = React.useState([
    {
      id: "A",
      name: "Container A",
      //helper function to create an array of draggbale items
      items: createData(3, (index) => `ITEM A${index + 1}`),
    },
    {
      id: "B",
      name: "Container B",
      //helper function to create an array of draggbale items
      items: createData(2, (index) => `ITEM B${index + 1}`),
    },
  ]);

  //remember to set up your sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      collisionDetection={closestCorners}
      sensors={sensors}
      //we will implment the handlers below
      onDragEnd={handleDragEnd}
      onDragOver={handleDragOver}
    >
      <SortableContext
        items={sortables}
        strategy={horizontalListSortingStrategy}
      >
        {sortables.map((s) => (
          <SortableContainer
            key={s.id}
            id={s.id}
            name={s.name}
            items={s.items}
          />
        ))}
      </SortableContext>
    </DndContext>
  );
}
```

We respond to two events in this example:

- `onDragOver` when a `SortableItem` is dragged over a `SortableContainer`;
- `onDragEnd` when a `SortableContainer` is sorted with other `SortableContainer's` or when a `SortableItem` is sorted within a `SortableContainer`.

In the `onDragOver` handler, we use two helper functions: `findContainer`, which finds the relevant container based on the id passed in, and `isSortingContainers`, which returns true if the active and over items are both `SortableContainers`:

```tsx
function findContainer(id?: string) {
  if (id) {
    //find the container id based on the id of container item
    const container = sortables?.find((i) =>
      i.items?.find((l) => l?.id === id)
    );

    return container?.id;
  }
}

function isSortingContainers(activeId: string, overId: string) {
  return (
    sortables.map((s) => s.id).includes(overId) &&
    sortables.map((s) => s.id).includes(activeId)
  );
}

function handleDragOver(event: DragOverEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!over || !activeId || !overId) return;
  const activeContainerId = findContainer(activeId);
  const overContainerId = findContainer(overId);

  //If there is no active container or over container, return early
  if (!overContainerId || !activeContainerId) return;

  //In this example we can not drag a container over another container, is if we are sorting the containers
  //we will return early and not update the state
  if (isSortingContainers(activeId, overId)) return;

  //Only update state when the active container is not the same as the over container
  if (activeContainerId !== overContainerId) {
    //Find active and over items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const overContainer = sortables.find((i) => i.id === overContainerId);
    const activeItems = activeContainer?.items || [];
    const activeIndex = activeItems.findIndex((i) => i.id === active.id);
    const overItems = overContainer?.items || [];
    const overIndex = sortables.findIndex((i) => i.id === over.id);

    //Need to find the newindex to insert the active item into the over container
    let newIndex: number;
    //check if container is empty, if it is we will add the active item to the end of the container
    if (sortables.map((s) => s.id).includes(over.id as string)) {
      newIndex = overItems.length + 1;
    } else {
      //if the container is not empty we will check if the active item is below the over item and update the index accordingly
      const isBelowOverItem =
        over &&
        active.rect.current.translated &&
        active.rect.current.translated.top > over.rect.top + over.rect.height;
      const modifier = isBelowOverItem ? 1 : 0;
      newIndex = overIndex >= 0 ? overIndex + modifier : overItems.length + 1;
    }

    const newItems = sortables.map((item) =>
      // Remove the active item from the old container
      item.id === activeContainerId
        ? {
            ...item,
            items: activeItems.filter((item) => item.id !== active.id),
          }
        : // Add the active item to the new container at the new index
        item.id === overContainerId
        ? {
            ...item,
            items: [
              ...item.items.slice(0, newIndex),
              activeItems[activeIndex],
              ...overItems.slice(newIndex, item.items.length),
            ],
          }
        : item
    );

    //update the state
    setSortables(newItems);
  }
}
```

In the `onDragEnd` handler, we handle two cases: sorting a `SortableContainer` and sorting a `SortableItem` within a `SortableContainer`:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  const activeId = active.id as string;
  const overId = over?.id as string;
  if (!activeId || !overId) return;
  const activeContainerId = findContainer(activeId);

  //If we are sorting the containers, we will update the state to reflect the new order of the containers
  if (isSortingContainers(activeId, overId)) {
    if (activeId !== overId) {
      setSortables((items) => {
        const oldIndex = sortables.findIndex((f) => f.id === activeId);
        const newIndex = sortables.findIndex((f) => f.id === overId);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  } else {
    //Update the state to reflect the new order of the items inside the containers, iuf we are sorting the items
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const activeItems = activeContainer?.items || [];
    const oldIndex = activeItems.findIndex((i) => i.id === activeId);
    const newIndex = activeItems.findIndex((i) => i.id === overId);
    const newItems = sortables.map((s) =>
      //Find the active container and update the items inside the container
      s.id === activeContainerId
        ? {
            ...s,
            items: arrayMove(s.items, oldIndex, newIndex),
          }
        : s
    );

    //Only update the state if the active item has moved
    if (oldIndex !== newIndex) {
      setSortables(newItems);
    }
  }
}
```

</Callout>

## Closing Thoughts

I hope I managed to demonstrate the power of DndKit. Its strength lies in its flexibility. You can use it to create anything from a simple to-do list to a complex drag-and-drop interface.

I hope you enjoyed this post. If you have any questions, you can reach me on Twitter [@kxlaa\_](https://twitter.com/kxlaa_) and I'll be happy to answer them.

Thank you for reading and happy coding!
