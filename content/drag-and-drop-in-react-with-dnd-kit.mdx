---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is an awesome library I recently discovered while working on the new dashboard at [Super](https://super.so/). It simplifies the complex task of creating Drag-and-Drop UI interactions, with some interesting patterns and concepts. I spent some time creating a lot of cool interactions with the library and wanted to share some of the things I learned.

If you're already familiar with DnD Kit, or just want to take a look at the code examples, you can jump straight to them [here](#examples). Otherwise, keep reading to learn more about the library and how to get started.

Let's begin!

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

From a high-level, most drag-and-drop UI interactions involve three elements:

- A **draggable component** that can be dragged
- A **droppable area** that draggable components can be dropped over
- A **system** that manages the interaction between the draggable components and the droppable areas

To see these elements in action, you can play with the demo below:

<FreeDnd />

In the demo above, the droppable area spans the entire viewport, enabling us to drag and drop our draggable components anywhere. This is similar to canvas-based applications like Figma and Excalidraw. But we can also have fixed, designated droppable areas for our draggable components, like this:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives:

- The `useDraggable` hook, which turns HTML elements into draggable sources that can be picked up, dragged, and dropped over droppable areas.
- The `useDroppable` hook, which sets up HTML elements as droppable areas that draggable elements can be dropped over; and
- The `DndContext`, which manages the interaction between draggable and droppable components via React Context API.

These primitives are exported from the `@dnd-kit/core` package; you can install it by running:

```shell
yarn add @dnd-kit/core
```

In more advanced drag-and-drop UI interactions, we also have sortable components. These are usually used in lists, where each list item is both a draggable component and a droppable area. When you drag a list item, it automatically sorts with other list items:

<SortableDnd />

To handle this use case, DnD-Kit exposes a set of presets from the `@dnd-kit/sortable` package:

- The `useSortable` hook, which turns HTML elements into sortable components. The `useSortable` hook is basically a combination of the `useDraggable` and `useDroppable` hooks; and
- The `SortableContext` which manages the interaction between sortable components.

You can install the presets by running:

```shell
yarn add @dnd-kit/sortable
```

Lets talk about these primitives and presets in more detail.

### Draggable

Dndkit enables us to create draggable components using the `useDraggable` hook. This hook takes an input object with a required, unique `id` as an argument and returns an object with several properties. We are currently interested in four of these properties:

1. `setNodeRef` - A callback ref we attach to the HTML element we want to make draggable. This is essential for providing dndkit with the element that needs to be dragged.
2. `listeners` - An object we spread on the HTML element that we use as a trigger or activator to start a drag event. We can use this to create drag handles for our draggable elements.
3. `attributes` - An object with sensible defaults for accessibility. We spread this object on the activator HTML element, along with the `listeners` object.
4. `transform` - An object with the x- and y-coordinates of a draggable element in 2D. This is updated during a drag event and we use it to update the CSS `translate` property, allowing us to move the draggable component on the screen.

<Callout intent="info" heading="Callback Refs">
  Callback refs are functions that receive a reference to a rendered HTML
  element as an argument. It is a way to access HTML elements directly in React.
  Learn more about them
  [here](https://julesblom.com/writing/ref-callback-use-cases).
</Callout>

Here is an example of how all these elements work together to create a draggable component:

```tsx
import { useDraggable } from "@dnd-kit/core";
//CSS helper for generating CSS transform strings
import { CSS } from "@dnd-kit/utilities";

function Draggable() {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id: "unique-id",
  });

  const style = {
    transform: CSS.Transform.toString(transform),
  };

  return (
    <button
      ref={setNodeRef}
      style={{ ...style }}
      {...listeners}
      {...attributes}
    >
      {/* Render whatever you like within */}
    </button>
  );
}
```

### Droppables

The `useDroppable` hook sets up HTML elements as droppable areas. It takes an input object with a required, unique `id` as an argument and returns an object with several properties. We are currently interested in two of these properties:

1. `setNodeRef` - a callback ref we attach to the HTML element we want to make droppable. This is how DndKit knows an element is a drop area.
2. `isOver` - a Boolean that indicates whether a draggable component is over a droppable area. We can use this to style droppable areas conditionally.

Here is how all these elements come together:

```tsx
import { useDroppable, isOver } from "@dnd-kit/core";

function Droppable() {
  const { setNodeRef } = useDroppable({
    id: "unique-id",
  });

  return (
    <div
      ref={setNodeRef}
      style={{
        // Change the bg color when a draggable component is over the droppable area
        backgroundColor: isOver ? "red" : "blue",
      }}
    >
      {/* Render whatever you like within */}
    </div>
  );
}
```

### DndContext

The `DndContext` manages the interactions between our draggable and droppable components. To make sure they work properly, we must wrap them within the `DndContext`:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";

function App() {
  return (
    <DndContext>
      <Draggable />
      <Droppable />
    </DndContext>
  );
}
```

The `<DndContext>` provides many props to configure the behaviour of our draggable and droppable components. For a full API reference, please refer to the [documentation](https://docs.dndkit.com/api-documentation/context-provider). The most important props at this point are the events-realted and sensors props.

#### Events

The DndContext emits various events throughout the drag-and-drop interaction. We can use the information from these events to configure the behavior of draggable and droppable components. The main events emitted are:

- `onDragStart`, which fires when a draggable is dragged and contains an object with information about the active draggable element.
- `onDragOver`, which fires when a draggable item is dragged over a droppable area. It contains an object with information about the droppable area and the draggable element.
- `onDragEnd`, which fires after a draggable item is dropped. It includes information on the active draggable `id` and whether the draggable item was dropped over a droppable area.
- `onDragCancel`, which fires if a drag operation is cancelled, e.g. if the user presses `escape` while dragging a draggable item.

We can use handler functions to respond to these events, using the event data to update the state of our draggable and droppable components in the UI.

To see when the `DndContext` emits different events, try out the demo below:

<DroppableDnd />

#### Sensors

With the many devices that can access the web, there are various input types that could trigger a drag event. These include a mouse, touchpad, keyboard, stylus pen, or a touchscreen. To detect these potential input types, Dndkit exposes the concept of sensors.

Sensors provide `DndContext` with a way to detect the different stages of a drag event triggered by specific input types. By default, `@dnd-kit/core` ships with four sensors: `MouseSensor`, `TouchSensor`, `KeyboardSensor`, and `PointerSensor`. These sensors are generally enough for most use cases. However, if they are not sufficient, you can build a custom sensor. For more information on this, check [here](https://docs.dndkit.com/api-documentation/sensors#custom-sensors).

By default, `DndContext` uses the Pointer and Keyboard sensors. To use other sensors, such as the Mouse and Touch sensors, initialize them separately using the `useSensor` hook:

```tsx
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";

function App() {
  const sensors = useSensors(
    useSensor(MouseSensor),
    useSensor(TouchSensor),
    useSensor(KeyboardSensor)
  );

  return <DndContext sensors={sensors}>{/* ... */}</DndContext>;
}
```

### Sortables

## Examples

Now that we've discussed the core concepts of dndkit, let's explore examples of how to use them to create various drag-and-drop interactions. We'll cover four common types:

- Free Drag-and-Drop
- Droppable Containers
- Single Container Sortable list
- Multi-Container Sortable list

### Free Drag-and-Drop

A user interface allows users to pick up and drag an element across the entire viewport.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
In this interaction, we have multiple draggable components. To build this, we need to create a Draggable Component with the useDraggable hook. This component takes a unique id, and a styles object as props:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

//First create a draggable component
type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform, isDragging } =
    useDraggable({
      id,
    });

  const transformStyles = transform
    ? {
        transform: CSS.Translate.toString(transform),
      }
    : {};

  return (
    <div
      ref={setNodeRef}
      style={{ ...transformStyles, ...styles }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

Next we need to set up our DndContext and the state of our Draggable components. We'll be storing the data about our draggable components as an array of objects in state. Each object should include a unique ID and the initial x and y position coordinates of the element:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  //initial draggble state
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

To allow our components to be moved around the page, we need to update their positions when a drag event ends. We'll use the `onDragEnd` event emitted by the `<DndContext />` to do this. This event contains the x- and y-positions of the active draggable element when it is dropped. In our handler function, we can use this information to update the position of our element in state:

```tsx
//Set up DndContext and the state of our draggable elements
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

//Create a handler function to respond to an ondragend event & update the position of the draggable element
export function App() {
  const [draggables, setDraggables] = React.useState([
    {
      id: 1,
      name: "OL",
      position: {
        x: 24,
        y: 24,
      },
    },
  ]);

  function handleDragEnd(ev: DragEndEvent) {
    const activeId = ev.active.id;

    //if there is no active draggable return
    if (!activeId) {
      return;
    }

    //find active draggable in state and update its position
    const draggable = draggables.find((x) => x.id === ev.active.id);
    draggable.position.x += ev.delta.x;
    draggable.position.y += ev.delta.y;
    const _draggables = draggables.map((d) =>
      d.id === draggable.id ? draggable : d
    );

    setDraggables(_draggables);
  }

  return (
    <div>
      <DndContext>
        {draggables.map((d) => (
          <Draggable
            //We pass the current position of the draggbale here ass CSS styles
            styles={{
              position: "absolute",
              left: `${d.position.x}px`,
              top: `${d.position.y}px`,
            }}
            key={d.id}
            id={d.id}
            name={d.name}
          />
        ))}
      </DndContext>
    </div>
  );
}
```

</Callout>

### Droppable Containers

A user interface allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<FreeDnDSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
To build this, we'll need to create both draggable and droppable components. The draggable component is similar to the one we made in the free DnD example above. To create a droppable component, we'll use the `useDropabale` hook. Similar to the Draggable component, this component takes a unique ID as props:

```tsx
import { useDroppable } from "@dnd-kit/core";
type DroppableProps = {
  id: string;
  children: React.ReactNode;
};

export function Droppable(props: DroppableProps) {
  const { id, children } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: props.id,
  });

  const style = {
    color: isOver ? "green" : undefined,
  };

  return (
    <div ref={setNodeRef} style={style}>
      {children}
    </div>
  );
}
```

Next, we need to set up our `DndContext` and the state of our draggable and droppable components. Since each droppable area can be associated with a group of draggable components, we can easily represent this relationship in state as an object. The key of the object will be the unique ID of the droppable area, and the value an array of draggable components.

Here is the code:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Droppable } from "./Droppable";
import { Draggable } from "./Draggable";

export function App() {
  const [items, setItems] = React.useState<Items>({
    A: [],
    B: [],
    ROOT: [
      {
        id: "7796433d-eb92-4543-b46e-6c7fc9c5b6d4",
        name: "AQ",
      },
      {
        id: "528ec37c-08f0-4908-8bcb-248ffa288289",
        name: "FU",
      },
    ],
  });

  //...other code seeting up the DndContext
}
```

To allow our draggable components to move between containers, we need a helper function, findContainer, which takes an ID and returns the relevant droppable container ID. We will be using this helper function in our handler function that responds to the onDragEnd event emitted by the `DndContext`. This event contains information about the active draggable component and the ID of the droppable area that it is over. We will use the findContainer helper function to find the items in the active and over containers and update them in state.

Here is the code:

```tsx

```

</Callout>

## Closing Thoughts
