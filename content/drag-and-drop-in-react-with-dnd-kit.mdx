---
title: "Drag & drop in React with Dnd Kit"
publishedAt: "2022-12-18"
description: "A simple guide to get started with Dnd Kit in React."
tags: ["React", "Typescript", "Tutorial"]
ogImage: "/assets/blog/dynamic-routing/cover.jpg"
thumbnail: "/assets/blog/dynamic-routing/cover.jpg"
postId: "drag-and-drop-in-react-with-dnd-kit"
---

DnD Kit is a relatively new, hook-based library that makes it easy to create performant and accessible drag-and-drop UI interactions in React. I have been using the library a lot at Super, particularly in our new dashboard, and I wanted to share some examples of the kind of interactions that can be built with it.

In this post, I will provide a brief overview of the core concepts behind `@dnd-kit` and then iâ€™ll move on to a number of [code examples](#examples) with explanations. If you need more detail about anything i cover, you can always consult the documentation [here](https://docs.dndkit.com/).

<Callout intent="info" heading="Intended Audience">
  This article assumes you have a basic understanding of React and Typescript.
</Callout>

## Core Concepts

Drag-and-drop interactions on the web typically involve three elements:

- a **draggable component** that can be dragged,
- a **droppable area** where draggable components can be dropped over, and
- a **system that manages** the interaction between the draggable components and the droppable areas.

To see how these elements typically come together, you can play with the demo below:

<FreeDnd />

In the demo, we can drag our draggable components and drop them anywhere on the page. However, we can also restrict the dropping of our draggable components to particular areas:

<DroppableDnd />

DndKit is designed around this approach, providing three core primitives exported from the `@dnd-kit/core` package:

1. The [`useDraggable`](https://docs.dndkit.com/api-documentation/draggable) hook - A React hook which makes HTML elements draggable.
2. The [`useDroppable`](https://docs.dndkit.com/api-documentation/droppable) hook - A React hook which makes HTML elements droppable areas.
3. The [`DndContext`](https://docs.dndkit.com/api-documentation/context-provider) - A context provider which manages the interaction between draggable and droppable components using the React Context API.

Drag-and-drop interactions often require more than just dragging and dropping components. For example, take a look at the demo below:

<SortableDnd />

In the demo, we have a list. When we drag a single item, it automatically sorts with its other siblings. This type of interaction is known as a sortable interface, where components are both draggable and droppable. We can refer to these components as "Sortable Components".

Sortable components can be used in a variety of ways. For instance, we can have multiple containers with sortable list items, enabling users to sort the containers, list items, and drag items between them:

<SortableMultiDnd />

To handle this use case, ` @dnd-kit` exposes a set of presets from the `@dnd-kit/sortable` package:

1. The `useSortable` hook - A react hook which makes HTML elements sortable. The hook is a combination of the `useDraggable` and `useDroppable` hooks.
2. The `SortableContext` - An additional context provider which manages the interactions between sortable components.

Let's now explore how to use the primitives and presets to create various drag-and-drop interactions.

## Examples

We'll be looking at four common types of drag and drop interactions:

1. **Free Drag-and-Drop** - Drag draggable components across the entire page, similar to apps such as Figma and Excalidraw.
2. **Droppable Containers** - Drag multiple draggable components into one or more designated droppable containers.
3. **Single Container Sortable List** - A sortable list within a single container.
4. **Multi-Container Sortable List** - Sortable lists within multiple sortable containers.

### Free Drag-and-Drop

A user interface that allows users to pick up and drag an element across the entire page.

<FreeDnDSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
First, we create a `Draggable` component with the `useDraggable` hook:

```tsx
import { useDraggable } from "@dnd-kit/core";
import { CSS } from "@dnd-kit/utilities";

type DraggableProps = {
  id: string;
  styles?: React.CSSProperties;
  children?: React.ReactNode;
};

function Draggable(props: DraggableProps) {
  const { id, styles, children } = props;
  const { attributes, listeners, setNodeRef, transform } = useDraggable({
    id,
  });

  return (
    <div
      //Sets up the draggable element
      ref={setNodeRef}
      style={{
        ...styles,
        //Updates the position of the draggable element as it is dragged
        transform: CSS.Translate.toString(transform),
      }}
      {...listeners}
      {...attributes}
    >
      {children}
    </div>
  );
}
```

This `Draggable` component takes a unique `id` and a `styles` object as `props`. We pass the `id` we receive as props as a field of the object we pass to the `useDraggable` hook; this `id` field in the object is required.

The `useDraggable` hook returns a number of properties. The ones we use are:

- `setNodeRef`: a callback ref we attach to the HTML element we want to make draggable (the div in the code above). This is essential for providing `@dnd-kit` with the element that needs to be dragged.
- `listeners`: an object we spread on the HTML element that serves as a trigger or activator to start a drag event.
- `attributes`: an object with sensible defaults for accessibility. We spread this object on the activator HTML element, along with the `listeners` object.
- `transform`: an object with the x- and y-coordinates of a draggable element in 2D, which is updated during a drag event. We use the values of the object to update the position of our draggable element with CSS via the `transform` property.

Next, we set up our `DndContext` and the state of our draggable components:

```tsx
import { DndContext } from "@dnd-kit/core";
import { Draggable } from "./Draggable";

export function App() {
  const [draggables, setDraggables] = React.useState([
    {
      id: "DG",
      name: "D",
      position: {
        x: 24,
        y: 24,
      },
    },
    {
      id: "KA",
      name: "K",
      position: {
        x: 164,
        y: 164,
      },
    },
  ]);

  //sensors are used to detect drag events see more at https://docs.dndkit.com/api-documentation/sensors
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );

  return (
    <DndContext
      sensors={sensors}
      //we implement this handler below
      onDragEnd={handleDragEnd}
    >
      {draggables.map((d) => (
        <Draggable
          {...d}
          key={d.id}
          //We pass the current position of the draggables here as CSS styles
          styles={{
            position: "absolute",
            left: `${d.position.x}px`,
            top: `${d.position.y}px`,
          }}
        />
      ))}
    </DndContext>
  );
}
```

The state of our draggable components is represented in an array of objects. Each object contains an `id`, `name`, and the current `position` of the component. We pass the current positions in state to the `style` object's left and top CSS properties with an `absolute` position, allowing the components to be dragged across the entire area.

We need a way to update the position of our draggable component while a user is dragging it. The `onDragEnd` event, emitted by `DndContext`, is triggered at the end of a drag event. It contains data such as the `position`, `id`, and more of the active draggable component. We can access this data with a handler function and use it to update the draggable components' positions in state:

```tsx
//Handler function to respond to an onDragEnd event
function handleDragEnd(ev: DragEndEvent) {
  const { active, delta } = ev;

  //if there is no active draggable, return
  if (!active) return;

  //find the active draggable in state
  const draggable = draggables.find((d) => d.id === active.id);

  //update the position of the active draggable
  draggable.position.x += delta.x;
  draggable.position.y += delta.y;

  setDraggables((draggables) =>
    //update the state of the active draggable with the new position
    draggables.map((d) => (d.id === draggable.id ? draggable : d))
  );
}
```

</Callout>

### Droppable Containers

A user interface that allows users to pick up and drag an element into designated droppable areas

<DroppableDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
For this interaction, we need a `Draggable` and `Droppable` Component. We already built the draggable component [`above`](#free-drag-and-drop), so there's no need to repeat it here.

For the `Droppable` component, we will be using the `useDropabale` hook:

```tsx
import React from "react";
import { useDroppable } from "@dnd-kit/core";

type DroppableProps = {
  id: string;
  children?: React.ReactNode;
  className?: string;
};

export function Droppable(props: DroppableProps) {
  const { children, id, className } = props;
  const { isOver, setNodeRef } = useDroppable({
    id: id,
  });

  const style = {
    background: isOver && !(id === "root") ? "#18181a" : "",
  };

  return (
    <div ref={setNodeRef} className={className} style={style}>
      {children}
    </div>
  );
}
```

The component takes a unique `id` and a `className` as `props`. We pass the `id` we receive as props as a field of the object we pass to the `useDroppable` hook; this `id` field in the object is required.

The `useDroppable` hook returns a number of properties. The ones we use are:

- `setNodeRef` - a callback ref we attach to the HTML element we want to make droppable. This is how `@dnd-kit` knows an element is a drop area.
- `isOver` - a boolean that indicates whether a draggable component is over a droppable area. We use this to style the droppable area conditionally.

Next, we set up our `DndContext` and the state of our draggable and droppable components:

```tsx
import React from "react";
import { DragOverEvent, DragStartEvent } from "@dnd-kit/core";
import {
  DndContext,
  KeyboardSensor,
  MouseSensor,
  TouchSensor,
  useSensor,
  DragOverlay,
  useSensors,
} from "@dnd-kit/core";
import "./styles.css";
import { Draggable } from "./Draggable";
import { Droppable } from "./Droppable";
import { items as defaultItems, Item } from "./items";

function App() {
  const sensors = useSensors(
    useSensor(KeyboardSensor),
    useSensor(TouchSensor),
    useSensor(MouseSensor)
  );
  const [draggables, setDraggables] = React.useState([...defaultItems]);
  const [droppables] = React.useState(["A", "B"]);
  const [activeItem, setActiveItem] = React.useState<Item | undefined>(
    undefined
  );

  return (
    <DndContext
      sensors={sensors}
      onDragOver={handleDragOver}
      onDragStart={handelDragStart}
    >
      <div className="app">
        <div className="containers">
          {droppables.map((id) => (
            <Droppable key={id} id={id} className="droppable">
              {draggables
                .filter((draggable) => draggable.containerId === id)
                .map((draggable) => (
                  <Draggable key={draggable.id} {...draggable} />
                ))}
            </Droppable>
          ))}
        </div>
        <Droppable id="root" className="root-droppable">
          {draggables
            .filter((draggable) => draggable.containerId === "root")
            .map((draggable) => (
              <Draggable key={draggable.id} {...draggable} />
            ))}
        </Droppable>
      </div>
      <DragOverlay>
        {activeItem && (
          <div className="draggable draggable-overlay">{activeItem.name}</div>
        )}
      </DragOverlay>
    </DndContext>
  );
}
```

We have three pieces of state:

- `draggables`: an array of objects with `id`, `name`, and `containerId` fields. The `containerId` field of all `draggables` is set to `root` by default.
- `droppables`: an array of unique strings of our
- `activeItem`: the state of the active draggable, which is `undefined` by default.

We use the `draggables` & `droppables` state to render our components. If the `containerId` of a draggable component is the same as the `id` of a droppable component, then the draggable component will be rendered as a child of the droppable component.

The `DragOverlay` component provides a way to render a draggable overlay that is not part of the normal document flow and is positioned relative to the viewport. We can use this component, for instance, to show a preview of where the draggable source will be when dropped.

To render the overlay, we need details from the draggable currently being dragged. We can get this information from the `onDragStart` event emitted by the `DndContext`. In the handler function, we set our state:

```tsx
function handelDragStart(ev: DragStartEvent) {
  const { active } = ev;
  const activeId = active.id;
  const activeItem = draggables.find((item) => item.id === activeId);
  setActiveItem(activeItem);
}
```

You can read more on the DragOverlay component [here](https://docs.dndkit.com/api-documentation/draggable/drag-overlay).

Finally, we need to update the state of our draggable components. To do this, we'll use the `onDragOver` event emitted by the `DndContext``. This event is triggered when a draggable is dragged over a droppable area. It provides us with information about the dragged element and the droppable area it is over.

We can use this data to check which container our draggable component is over and update our state accordingly:

```tsx
function handleDragOver(ev: DragOverEvent) {
  const { active, over } = ev;
  if (!over) return;
  const activeId = active.id;
  const overId = over.id;

  setDraggables((prev) => {
    return prev.map((item) => {
      if (item.id === activeId) {
        return {
          ...item,
          containerId: overId,
        };
      }
      return item;
    });
  });
}
```

</Callout>

### Single Container Sortables

A container containing a list of items that can be rearranged by dragging them.

<SortableDndSandPack />

<Callout dropdown intent='default' heading='Code Breakdown'>
First, we create a `SortableItem` component with the `useSortable` hook:

```tsx
import { CSS } from "@dnd-kit/utilities";
import { useSortable } from "@dnd-kit/sortable";
import { DragHandleDots2Icon } from "@radix-ui/react-icons";

type SortableItemProps = {
  id: string;
  name?: string;
};

export function SortableItem(props: SortableItemProps) {
  const { name, id } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: id,
  });

  //set up the transform and transition styles for the draggable component
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }}>
      {/** add the drag handle */}
      <DragHandleDots2Icon
        className="drag-handle"
        {...listeners}
        {...attributes}
      />
      <span>{name}</span>
    </div>
  );
}
```

The component takes two props: a unique `id` and a `name`. The `id` is passed to the `useSortable` hook with an object that requires it.

The `useSortable` hook is similar to the `useDraggable` hook. In addition to what the `useDraggable` hook returns, it also provides:

- `isDragging` - A boolean set to `true` when dragging a sortable component.
- `transition` - CSS animations to be applied to the sortable Component.

Next, we set up our `DndContext` and the state of our `SortableItem` components:

```tsx
import React from "react";
import type { DragEndEvent } from "@dnd-kit/core";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { SortableItem } from "./SortableItem";

export default function App() {
  const [sortables, setSortables] = React.useState([
    {
      id: "dnuannvBxx",
      name: "GOLD",
    },
    {
      id: "mrY2amrFiv",
      name: "BRONZE",
    },
    {
      id: "Y7UE3g7kD2",
      name: "APRICOT",
    },
    {
      id: "kZ9B3D_JyO",
      name: "BEIGE",
    },
  ]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  return (
    <DndContext
      //collision detection algorithm best suited for single container sortables,
      //see more at https://docs.dndkit.com/api-documentation/context-provider/collision-detection-algorithms
      collisionDetection={closestCenter}
      sensors={sensors}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={sortables}
        //sorting strategy suited for vertical lists
        //see https://docs.dndkit.com/presets/sortable#sorting-strategies for more
        strategy={verticalListSortingStrategy}
      >
        <div className="app">
          {sortables.map((s) => (
            <SortableItem key={s.id} {...s} />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );
}
```

Finally, we update the positions of our sortable items at the end of the drag event using the `onDragEnd` event emitted by the `DndContext`:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  //if there is no active draggable or no droppable container, return
  if (!over || !active) return;
  const activeId = active.id;
  const overId = over?.id;

  if (activeId && overId && active.id !== over.id) {
    setSortables((items) => {
      //find the index of the active and over items and use arrayMove to update the items in state
      const oldIndex = sortables.findIndex((f) => f.id === activeId);
      const newIndex = sortables.findIndex((f) => f.id === overId);
      return arrayMove(items, oldIndex, newIndex);
    });
  }
}
```

</Callout>

### Multi-Container Sortables

A list that can be sorted and items that can be dropped into multiple containers.

<SortableMultiDndSandPack />

<Callout intent='default' dropdown heading='Code Breakdown'>
For this interaction, we need a `SortableItem` and `SortableContainer` Component. We already built the `SortableItem` component above, so there's no need to repeat it here.

The `SortableContainer` component, is quite similar to the `SortableItem` component, it uses the `useSortable` hook as well:

```tsx
import {
  SortableContext,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Item } from "./items";
import { CSS } from "@dnd-kit/utilities";
import { useDroppable } from "@dnd-kit/core";
import { SortableItem, OverlayItem } from "./SortableItem";

export type SortableContainerProps = {
  id: string;
  name?: string;
  items: Item[];
};

export function SortableContainer(props: SortableContainerProps) {
  const { name, id, items } = props;
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id: id,
    data: { name, type: "container" },
  });
  const style = {
    transform: CSS.Translate.toString(transform),
    transition,
    opacity: isDragging ? 0.2 : 1,
  };

  return (
    <div ref={setNodeRef} style={{ ...style }} className="sortable-container">
      <div>
        <div
          {...listeners}
          {...attributes}
          className="sortable-container_header"
        >
          {name}
        </div>
        <div className="sortable-container_wrapper">
          {items.length === 0 ? (
            //Render a message if container is empty
            <div key={id} className="droppable">
              List is empty
            </div>
          ) : (
            <SortableContext
              items={items}
              strategy={verticalListSortingStrategy}
            >
              {items.map((s) => (
                <SortableItem {...s} key={s.id} />
              ))}
            </SortableContext>
          )}
        </div>
      </div>
    </div>
  );
}
```

The component takes a unique `id`, a `name`, and an array of sortable `items` as props. The children of the `SortableContainer` are an array of sortable items rendered within the `SortableContext` component. This ensures that we can sort these items within their respective `SortableContainer`. The container itself is sortable, so we hook it up to the `useSortable` hook.

We also need to create an overlay component for our `DragOverlay` component:

```tsx
import { OverlayItem } from "./SortableItem";

export function OverlayContainer(props: SortableContainerProps) {
  const { name, id, items } = props;

  return (
    <div className="sortable-container">
      <div>
        <div className="sortable-container_header overlay">{name}</div>

        <div className="sortable-container_wrapper">
          {items.length === 0 ? (
            <div key={id} className="droppable">
              List is empty
            </div>
          ) : null}
          {items.map((s) => (
            //overlay component for sortable item component
            <OverlayItem {...s} key={s.id} />
          ))}
        </div>
      </div>
    </div>
  );
}
```

Next, we set the state of our components. Our state has the following shape:

```tsx
export const items = [
  {
    id: "Container A",
    name: "Container A",
    items: [
      { id: 1, name: `ITEM A1` },
      { id: 2, name: `ITEM A2` },
    ],
  },
  {
    id: "Container B",
    name: "Container B",
    items: [
      { id: 1, name: `ITEM B1` },
      { id: 2, name: `ITEM B2` },
    ],
  },
];
```

Each container has an `id`, `name` and an array of `items`. We will update this state based on the drag actions performed by our users.

Weâ€™ll use our state in the `DndContext`, like so:

```tsx
import {
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  closestCorners,
  DragEndEvent,
  DragOverEvent,
  DragStartEvent,
  DragOverlay,
} from "@dnd-kit/core";
import {
  arrayMove,
  horizontalListSortingStrategy,
  SortableContext,
  sortableKeyboardCoordinates,
} from "@dnd-kit/sortable";
import React from "react";
import { initialItems, Item } from "./items";
import {
  OverlayContainer,
  SortableContainer,
  SortableContainerProps,
} from "./SortableContainer";
import { OverlayItem } from "./SortableItem";

export default function App() {
  const [sortables, setSortables] = React.useState([...initialItems]);
  const [activeItem, setActiveItem] = React.useState<
    SortableContainerProps | Item | null
  >(null);
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );
  const containerIds = sortables.map((s) => s.id);

  return (
    <DndContext
      collisionDetection={closestCorners}
      sensors={sensors}
      //We implement these below
      onDragEnd={handleDragEnd}
      onDragOver={handleDragOver}
      onDragStart={handleDragStart}
    >
      <SortableContext
        items={sortables}
        strategy={horizontalListSortingStrategy}
      >
        <div className="app">
          {sortables.map((s) => (
            <SortableContainer
              key={s.id}
              id={s.id}
              name={s.name}
              items={s.items}
            />
          ))}
        </div>
      </SortableContext>
      <DragOverlay>
        {activeItem ? (
          <>
            {containerIds.includes(activeItem.id) ? (
              <OverlayContainer {...(activeItem as SortableContainerProps)} />
            ) : (
              <OverlayItem {...(activeItem as Item)} />
            )}
          </>
        ) : null}
      </DragOverlay>
    </DndContext>
  );
}
```

As discussed in the single [container sortable example](#), we are rendering our drag overlay with the data of the item being actively dragged on line 65. The only difference here is that we can be dragging either a sortable item or a sortable container, so we need to check whether the active item is a sortable container or sortable item.

Now lets implement our handlers, weâ€™ll need to helper functions:

```tsx
//Returns the id of a container based on the id of any of its items
function findContainer(id?: string) {
  if (id) {
    if (containerIds.includes(id)) return id;
    const container = sortables?.find((i) =>
      i.items?.find((l) => l?.id === id)
    );

    return container?.id;
  }
}

//checks if we are sorting containers
function isSortingContainers({
  activeId,
  overId,
}: {
  activeId: string;
  overId: string;
}) {
  const isActiveContainer = containerIds.includes(activeId);
  const isOverContainer = findContainer(overId);
  return !!isActiveContainer && !!isOverContainer;
}
```

Let's start with the `handleDragStart` handler function. Remember, this function responds to the `onDragStart` event emitted by the `DndContext`:

```tsx
function handleDragStart(event: DragStartEvent) {
  const { active } = event;
  const activeId = active.id;

  if (containerIds.includes(activeId)) {
    const container = sortables.find((i) => i.id === activeId);
    if (container) setActiveItem(container);
  } else {
    const containerId = findContainer(activeId);
    const container = sortables.find((i) => i.id === containerId);
    const item = container?.items.find((i) => i.id === activeId);
    if (item) setActiveItem(item);
  }
}
```

The event object contains information about the component being dragged, such as its `id`. We check if this `id` is a sortable container or a sortable item and update the state of our active item accordingly.

Next is the `handleDragOver` handler function:

```tsx
function handleDragOver(event: DragOverEvent) {
  const { active, over } = event;
  if (!active || !over) return;
  const activeId = active.id as string;
  const overId = over.id as string;
  //find the container id of the active item and the container id of the item being dragged over
  const activeContainerId = findContainer(activeId);
  const overContainerId = findContainer(overId);

  if (!overContainerId || !activeContainerId) return;

  //We don't want to sort containers, so we return early if we are sorting containers
  if (isSortingContainers({ activeId, overId })) return;

  //we only want to update the state if we are dragging over a different container
  if (activeContainerId !== overContainerId) {
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const overContainer = sortables.find((i) => i.id === overContainerId);
    const activeItems = activeContainer?.items || [];
    const activeIndex = activeItems.findIndex((i) => i.id === activeId);
    const overItems = overContainer?.items || [];
    const overIndex = sortables.findIndex((i) => i.id === overId);
    let newIndex: number;

    if (containerIds.includes(overId)) {
      //if the container is empty, and we drag over it, the overId would be the id of that container and not
      //the id of any of its items since it is empty so we want to add the item to the end of
      //the container basically making it the last item
      newIndex = overItems.length + 1;
    } else {
      //Get the new index of the item being dragged over if it is a sortable item in the over container
      const isBelowOverItem =
        over &&
        active.rect.current.translated &&
        active.rect.current.translated.top > over.rect.top + over.rect.height;
      const modifier = isBelowOverItem ? 1 : 0;
      newIndex = overIndex >= 0 ? overIndex + modifier : overItems.length + 1;
    }

    //Update the state
    const newItems = sortables.map((item) =>
      // Remove the active item from the old list
      item.id === activeContainerId
        ? {
            ...item,
            items: activeItems.filter((item) => item.id !== active.id),
          }
        : // Add the active item to the new list
        item.id === overContainerId
        ? {
            ...item,
            items: [
              ...item.items.slice(0, newIndex),
              activeItems[activeIndex],
              ...overItems.slice(newIndex, item.items.length),
            ],
          }
        : item
    );

    setSortables(newItems);
  }
}
```

Finally, the `handleDragEnd` function:

```tsx
function handleDragEnd(event: DragEndEvent) {
  const { active, over } = event;
  if (!active || !over) return;
  const activeId = active.id as string;
  const overId = over.id as string;
  const activeContainerId = findContainer(activeId);
  const overContainerId = findContainer(overId);

  if (isSortingContainers({ activeId, overId })) {
    if (activeId !== overId) {
      setSortables((items) => {
        const oldIndex = sortables.findIndex((f) => f.id === activeContainerId);
        const newIndex = sortables.findIndex((f) => f.id === overContainerId);
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  }

  if (activeContainerId === overContainerId) {
    const activeContainer = sortables.find((i) => i.id === activeContainerId);
    const activeItems = activeContainer?.items || [];
    const oldIndex = activeItems.findIndex((i) => i.id === activeId);
    const newIndex = activeItems.findIndex((i) => i.id === overId);
    const newItems = sortables.map((s) =>
      s.id === activeContainerId
        ? {
            ...s,
            items: arrayMove(s.items, oldIndex, newIndex),
          }
        : s
    );

    if (oldIndex !== newIndex) {
      setSortables(newItems);
    }
  }
}
```

</Callout>

## Closing Thoughts

I hope I managed to demonstrate the power of DndKit. Its strength lies in its flexibility. You can use it to create anything from a simple to-do list to a complex drag-and-drop interface.

I hope you enjoyed this post. If you have any questions, you can reach me on Twitter [@kxlaa\_](https://twitter.com/kxlaa_) and I'll be happy to answer them.

Thank you for reading and happy coding!
